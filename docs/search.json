[
  {
    "objectID": "eng.html",
    "href": "eng.html",
    "title": "Eng.Study",
    "section": "",
    "text": "개인적으로 공부한 영어를 정리합니다\n\n\n\n\n\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Title\n        \n     \n  \n\n\n\n\n\n\nDate\n\n\nTitle\n\n\nDescription\n\n\nCategories\n\n\n\n\n\n\n2022/10/16\n\n\n신난다, 흥분된다!\n\n\nI'm so excited. 말고 다른 표현은?\n\n\ntag\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2022-01-19-Drawing-multiple-ROC-Curves-in-a-single-plot/2022-01-19-Drawing-multiple-ROC-Curves-in-a-single-plot.html",
    "href": "posts/2022-01-19-Drawing-multiple-ROC-Curves-in-a-single-plot/2022-01-19-Drawing-multiple-ROC-Curves-in-a-single-plot.html",
    "title": "여러개의 ROC-Curves를 하나의 plot 안에 그리는 방법",
    "section": "",
    "text": "Importing the necessary libraries\n\nimport pandas as pd\nimport numpy as np\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nsns.set()\n\nimport warnings\nwarnings.filterwarnings('ignore')\n\n\n\nLoad a toy Dataset from sklearn\n\nfrom sklearn import datasets\nfrom sklearn.model_selection import train_test_split\n\ndata = datasets.load_breast_cancer()\n\nX = data.data\ny= data.target\n\nX_train, X_test, y_train, y_test = train_test_split(X, y,\n                                                   test_size=.25,\n                                                   random_state=43)\n\n\n\nTraining multiple classifiers and recording the results\n이 장에서는 몇번의 단계를 실행하게 됩니다: 1. 분류기를 인스턴스화하고 목록을 생성 2. 결과 테이블을 DataFrame으로 정의 3. 모델 훈련 및 결과 기록\n우리가 훈련 세트에서 모델을 훈련하고 테스트 세트에서 확률을 예측할겁니다. 확률을 예측한 후 거짓 긍정 비율(FPR), 참 긍정 비율(TPR) 및 AUC 점수를 계산합니다.\n\n# Import the classifiers\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.ensemble import RandomForestClassifier\n\nfrom sklearn.metrics import roc_curve, roc_auc_score\n\n# Instantiate the classfiers and make a list\nclassifiers = [LogisticRegression(random_state=1234), \n               GaussianNB(), \n               KNeighborsClassifier(), \n               DecisionTreeClassifier(random_state=1234),\n               RandomForestClassifier(random_state=1234)]\n\n# Define a result table as a DataFrame\nresult_table = pd.DataFrame(columns=['classifiers', 'fpr','tpr','auc'])\n\n# Train the models and record the results\nfor cls in classifiers:\n    model = cls.fit(X_train, y_train)\n    yproba = model.predict_proba(X_test)[::,1]\n    \n    fpr, tpr, _ = roc_curve(y_test,  yproba)\n    auc = roc_auc_score(y_test, yproba)\n    \n    result_table = result_table.append({'classifiers':cls.__class__.__name__,\n                                        'fpr':fpr, \n                                        'tpr':tpr, \n                                        'auc':auc}, ignore_index=True)\n\n# Set name of the classifiers as index labels\nresult_table.set_index('classifiers', inplace=True)\n\n\n\nPlot the figure\n\nfig = plt.figure(figsize=(8,6))\n\nfor i in result_table.index:\n    plt.plot(result_table.loc[i]['fpr'], \n             result_table.loc[i]['tpr'], \n             label=\"{}, AUC={:.3f}\".format(i, result_table.loc[i]['auc']))\n    \nplt.plot([0,1], [0,1], color='orange', linestyle='--')\n\nplt.xticks(np.arange(0.0, 1.1, step=0.1))\nplt.xlabel(\"Flase Positive Rate\", fontsize=15)\n\nplt.yticks(np.arange(0.0, 1.1, step=0.1))\nplt.ylabel(\"True Positive Rate\", fontsize=15)\n\nplt.title('ROC Curve Analysis', fontweight='bold', fontsize=15)\nplt.legend(prop={'size':13}, loc='lower right')\n\nplt.show()\n\n\n\n\n아래의 코드를 이용해서 figure를 저장할 수 있습니다.\n\nfig.savefig('multiple_roc_curve.png')\n\n\n\n\n\n라이센스https://creativecommons.org/licenses/by/4.0/deed.ko"
  },
  {
    "objectID": "posts/2021-02-18-10-steps-to-become-a-data-scientist/index.html",
    "href": "posts/2021-02-18-10-steps-to-become-a-data-scientist/index.html",
    "title": "데이터 과학자(Data Scientist)가 되기 위한 10단계",
    "section": "",
    "text": "이 포스팅은 이 글 에 있는 포스팅을 번역한 내용입니다. 오역이나 의역이 있을 수 있습니다.\nOriginal source of this posting os form this article If the original quthor requests deletion, it will be deleted immediately.\n최고의 엔지니어라도 data scientist가 되는건 쉽지 않습니다. 그러나 누구에게나 어렵지는 않으며 미리 알아야 할 몇 가지가 있습니다. 이 기사에서는 이를 살펴보고 데이터과학에서 성공 하기위한 로드맵을 제공합니다."
  },
  {
    "objectID": "posts/2021-02-18-10-steps-to-become-a-data-scientist/index.html#what-you-need-to-do",
    "href": "posts/2021-02-18-10-steps-to-become-a-data-scientist/index.html#what-you-need-to-do",
    "title": "데이터 과학자(Data Scientist)가 되기 위한 10단계",
    "section": "1. What you need to do",
    "text": "1. What you need to do\n\n목표 시간 설정하라\n코드를 작성하기 위해 알아야 할 지식/경험을 계획하라\n훌륭한 조언을 해주는 똑똑한 사람에게 시간을 할애하라\n흥미로운 데이터셋을 선택하고 검색해보아라\n가장 큰 도전은 시작하는 것\n이진 분류를 잊어라 : 교차 검증(cross-validation) 및 베이지안 알고리즘(Bayesian algorithms)은 훌륭한 데이터 과학자가 되는데 도움이 될 것임\n데이터 과학 인터뷰에서 올바르게 질문하는 방법을 배워라"
  },
  {
    "objectID": "posts/2021-02-18-10-steps-to-become-a-data-scientist/index.html#problem-statement",
    "href": "posts/2021-02-18-10-steps-to-become-a-data-scientist/index.html#problem-statement",
    "title": "데이터 과학자(Data Scientist)가 되기 위한 10단계",
    "section": "2. Problem Statement",
    "text": "2. Problem Statement\n모든 질문에 문제 서술을 영어로 작성합니다. 제가 이미 데이터 과학의 문제들을 읽을 수 있게 포스트로 작성해놨습니다."
  },
  {
    "objectID": "posts/2021-02-18-10-steps-to-become-a-data-scientist/index.html#write-some-code",
    "href": "posts/2021-02-18-10-steps-to-become-a-data-scientist/index.html#write-some-code",
    "title": "데이터 과학자(Data Scientist)가 되기 위한 10단계",
    "section": "3. Write some code",
    "text": "3. Write some code\n코드를 작성하고 돌려보세요. 면접관은 코드를 보고 질문할 것입니다.\n\n데이터 준비에 얼마나 시간이 걸리는지\n문제를 해결하기 위해 팀에 몇명이 필요한지\n무엇이 잘못 될 수 있나요? 이건 작업하기 쉬운 도구 3가지를 선택하는 힌트를 줍니다.\n문제를 해결하는 데 사용할 도구를 작성하세요"
  },
  {
    "objectID": "posts/2021-02-18-10-steps-to-become-a-data-scientist/index.html#prepare-and-evaluate-your-answers",
    "href": "posts/2021-02-18-10-steps-to-become-a-data-scientist/index.html#prepare-and-evaluate-your-answers",
    "title": "데이터 과학자(Data Scientist)가 되기 위한 10단계",
    "section": "4. Prepare and evaluate your answers",
    "text": "4. Prepare and evaluate your answers\n간결하면서 독창적인 해결방법이 있는지 확인합니다."
  },
  {
    "objectID": "posts/2021-02-18-10-steps-to-become-a-data-scientist/index.html#review-your-answers",
    "href": "posts/2021-02-18-10-steps-to-become-a-data-scientist/index.html#review-your-answers",
    "title": "데이터 과학자(Data Scientist)가 되기 위한 10단계",
    "section": "5. Review your answers",
    "text": "5. Review your answers\n답변을 수정하고 기존 framework나 tool을 사용하지 않는 이유를 스스로에게 물어봅니다.\n이러면 스스로 더 배울 필요가 있는 영역을 구분하고 향후 면접을 위해 자료를 작성하는데 도움이 됩니다."
  },
  {
    "objectID": "posts/2021-02-18-10-steps-to-become-a-data-scientist/index.html#show-your-solution-to-the-problem",
    "href": "posts/2021-02-18-10-steps-to-become-a-data-scientist/index.html#show-your-solution-to-the-problem",
    "title": "데이터 과학자(Data Scientist)가 되기 위한 10단계",
    "section": "6. Show your solution to the problem",
    "text": "6. Show your solution to the problem\n추가로, 해결방법을 준비해 제 3자인 면접 관련 조직에게 연락을취해 보여주고 도움을 받으면 좋습니다.\n당신의 해결방법을 노트북에 준비하고 팀과 해결방법에 대해 토의합니다."
  },
  {
    "objectID": "posts/2021-02-18-10-steps-to-become-a-data-scientist/index.html#identify-assumptions",
    "href": "posts/2021-02-18-10-steps-to-become-a-data-scientist/index.html#identify-assumptions",
    "title": "데이터 과학자(Data Scientist)가 되기 위한 10단계",
    "section": "7. Identify Assumptions",
    "text": "7. Identify Assumptions\n면접관이 회사에 있다고 가정하고 해야할 일들을 정의하세요. 다른 사람들로부터 스스로 돋보이기 위해서는 이 가정은 생략/타협하면 안됩니다."
  },
  {
    "objectID": "posts/2021-02-18-10-steps-to-become-a-data-scientist/index.html#identify-solutions",
    "href": "posts/2021-02-18-10-steps-to-become-a-data-scientist/index.html#identify-solutions",
    "title": "데이터 과학자(Data Scientist)가 되기 위한 10단계",
    "section": "8. Identify Solutions",
    "text": "8. Identify Solutions\n팀이 예상한 것들과 해야할 일들을 확인해보세요. 시간이 있다면 이러한 것들을 검토해보는 것도 좋습니다."
  },
  {
    "objectID": "posts/2021-02-18-10-steps-to-become-a-data-scientist/index.html#use-the-pareto-principle",
    "href": "posts/2021-02-18-10-steps-to-become-a-data-scientist/index.html#use-the-pareto-principle",
    "title": "데이터 과학자(Data Scientist)가 되기 위한 10단계",
    "section": "9. Use the Pareto Principle",
    "text": "9. Use the Pareto Principle\n통계의 개념 인 파레토 분포 법칙을 사용하세요. 이 경우 분포는 독립 이벤트 중 가장 좋은 결과를 제공할 가능성이 높습니다."
  },
  {
    "objectID": "posts/2021-02-18-10-steps-to-become-a-data-scientist/index.html#build-a-model",
    "href": "posts/2021-02-18-10-steps-to-become-a-data-scientist/index.html#build-a-model",
    "title": "데이터 과학자(Data Scientist)가 되기 위한 10단계",
    "section": "10. Build a model",
    "text": "10. Build a model\n모든 질문에는 가지고 있는 데이터에 맞는 답이 있습니다. 강력한 해결방법을 정의하고 적용하는데 시간을 투자하여 향후 있을 면접에서 입증하세요.\n프로그래밍 경험은 데이터 과학에서 매우 중요합니다. 코드없이 코드를 실행하고 버그를 찾아야합니다. 이 경우 코드가 없는 것보다 더 나쁜 코드는 없습니다. 코드를 다시 작성하고 버그를 수정하라는 메시지가 보인다면 data scientist에게 문의하세요.\n프로그래밍 언어의 차이는 문화차이보다 중요하지 않습니다. 두 그룹의 learning curve가 당신이 좋은 기회를 갖기 위해 어디에 집중해야 하는지 고르는 데 도움이 될 겁니다."
  },
  {
    "objectID": "posts/2021-04-15-docker-run-vs-cmd-vs-entryporint/index.html",
    "href": "posts/2021-04-15-docker-run-vs-cmd-vs-entryporint/index.html",
    "title": "🐳 Dockerfile 명령어 RUN, CMD, ENTRYPOINT 차이",
    "section": "",
    "text": "Dockerfile 을 작성하다 보면 RUN, CMD, ENTRYPOINT 차이를 알아야 할 경우가 생기게 됩니다. 세 가지 명령어를 잘 모르고 사용하게 된다면 곤란한 상황을 겪게 될수도있습니다."
  },
  {
    "objectID": "posts/2021-04-15-docker-run-vs-cmd-vs-entryporint/index.html#tldr",
    "href": "posts/2021-04-15-docker-run-vs-cmd-vs-entryporint/index.html#tldr",
    "title": "🐳 Dockerfile 명령어 RUN, CMD, ENTRYPOINT 차이",
    "section": "TL;DR",
    "text": "TL;DR\n\nRUN\n이미지 생성시 새로운 레이어를 생성하여 명령어를 실행하게 됩니다. 보통 아래와 같은 방식으로 활용하게 됩니다.\nRUN apt-get install -y curl\n# 또는 \nRUN chmod -R 777 /tmp\nCMD\ndefault 명령이나 파라미터를 설정할 수 있습니다. 우리가 도커 이미지를 사용하여 docker run 명령어로 컨테이너를 생성할 경우 생성 후에 실행될 커맨드를 입력해주지 않는다면, CMD 명령어를 사용하여 작성된 커맨드가 기본으로 실행됩니다. 또한 바로 다음에 설명할 ENTRYPOINT의 기본 파라미터를 설정할 수도 있습니다. 즉, CMD 는 컨데이터를 실행할 때 기본으로 사용되는 명령어를 설정하는 것입니다.\nENTRYPOINT\ndocker run 명령어로 컨테이너를 생성 후 실행되는 명령어입니다."
  },
  {
    "objectID": "posts/2021-04-15-docker-run-vs-cmd-vs-entryporint/index.html#run",
    "href": "posts/2021-04-15-docker-run-vs-cmd-vs-entryporint/index.html#run",
    "title": "🐳 Dockerfile 명령어 RUN, CMD, ENTRYPOINT 차이",
    "section": "RUN",
    "text": "RUN\n보통 이미지에 새로운 패키지를 설치하거나 명령어를 실행시킬 경우 사용됩니다.\nFROM ubuntu:18.04\nRUN apt-get update\nRUN apt-get install -y python3 python3-pip wget git less neovim\nRUN pip3 install pandas\nRUN 명령은 실행할 때마다 레이어가 생성됩니다. 따라서 RUN 명령어 하나에 통합해준다면 보다 깔끔하게 레이어를 관리할 수 있습니다.\n# example\nFROM ubuntu:18.04\nRUN apt-get update \\\n    && apt-get install -y python3 python3-pip wget git less neovim \\\n    && pip3 install pandas"
  },
  {
    "objectID": "posts/2021-04-15-docker-run-vs-cmd-vs-entryporint/index.html#cmd",
    "href": "posts/2021-04-15-docker-run-vs-cmd-vs-entryporint/index.html#cmd",
    "title": "🐳 Dockerfile 명령어 RUN, CMD, ENTRYPOINT 차이",
    "section": "CMD",
    "text": "CMD\ndocker run 명령어 실행 시 실행 될 기본 명령어를 설정하거나, 아래에 있는 ENTRYPOINT 의 기본 명령어 파라미터를 설정할 때 사용됩니다. CMD 명령어는 보통 컨테이너를 실행할 때 사용할 기본 명령어를 설정하는 것입니다.\n\nCMD [\"executable\",\"param1\",\"param2\"] (exec form, preferred)\nCMD [\"param1\",\"param2\"] (sets additional default parameters for ENTRYPOINT in exec form)\nCMD command param1 param2 (shell form)\n\nFROM ubuntu:18.04\nCMD echo \"Hello\"\n위와 같이 작성하여 만들어진 이미지를 docker run (옵션 x) 명령어 실행 시 CMD 명령어가 실행되어 “Hello” 를 출력하게 됩니다.\n하지만, 두 번째 줄에 작성한 CMD echo \"Hello\" 와 별개로 docker run -it &lt;image_name&gt; echo \"Hello world\" 명령어를 주게 되면, dockerfile 에서 작성한 “Hello”는 무시되고 “hello world”를 출력하게 됩니다.\nCMD는 여러 번 dockerfile에 작성할 수 있지만, 가장 마지막에 작성된 CMD 만이 실행(override)됩니다."
  },
  {
    "objectID": "posts/2021-04-15-docker-run-vs-cmd-vs-entryporint/index.html#entrypoint",
    "href": "posts/2021-04-15-docker-run-vs-cmd-vs-entryporint/index.html#entrypoint",
    "title": "🐳 Dockerfile 명령어 RUN, CMD, ENTRYPOINT 차이",
    "section": "ENTRYPOINT",
    "text": "ENTRYPOINT\ndocker run 명령어로 컨테이너를 생성 후 실행되는 명령어입니다.\n\nENTRYPOINT [“executable”, “param1”, “param2”] (exec form, preferred)\nENTRYPOINT command param1 param2 (shell form)\n\nCMD 와의 차이를 쉽게 설명하자면, ENTRYPOINT 는 docker run 뒤에 명령어 작성과 무관하게 실행되는 명령어입니다.\nFROM ubuntu:18.04\nENTRYPOINT [\"/bin/echo\", \"Hi\"]\nCMD echo \"Hello\"\n$ docker run -it &lt;image_name&gt;\nHi Hello\n$ docker run -it &lt;image_name&gt; Mother\nHi Mother\n차이를 아시겠나요?\n그렇다면, 변수를 사용하기 위해서는?\nFROM ubuntu:18.04\nENTRYPOINT echo $HOME\n$ docker run -it &lt;image_name&gt;\n/home"
  },
  {
    "objectID": "posts/2021-02-19-extract-google-account-profile-picture/index.html",
    "href": "posts/2021-02-19-extract-google-account-profile-picture/index.html",
    "title": "구글 프로필 사진 다운로드하기",
    "section": "",
    "text": "google\n\n\n구글 프로필 사진을 다운받아야 할 경우가 가끔 있다. 한글로 검색해보니 정보가 나오지 않아서 검색 결과의 내용을 정리해 두고자 한다.\n여러개의 구글 계정을 사용중이라면 CTRL + SHIFT + N 을 눌러 private window 를 하나 만든다.\n\n프로필 사진을 다운받고자 하는 계정으로 gmail같은 구글 서비스를 로그인 한다.\nhttps://get.google.com/albumarchive 에 접속한다.\n프로필 사진 &gt; Profile Photos 으로 이동한다. 여기에서 계정의 모든 프로필 사진들을 찾을 수 있다.\n우측 상단 구석에 있는 triple dot 버튼을 사용해서 하나의 사진을 다운받거나 모든 사진을 다운받을 수 있다.\n\n\n\n\n라이센스https://creativecommons.org/licenses/by/4.0/deed.ko"
  },
  {
    "objectID": "posts/2022-02-18-DESeq-example/2022-02-18-DESeq-example.html",
    "href": "posts/2022-02-18-DESeq-example/2022-02-18-DESeq-example.html",
    "title": "R DESeq2 패키지 python으로 포팅",
    "section": "",
    "text": "DESeq2을 파이썬의 rpy2 라이브러리를 통해 포팅하는 방법은 여기를 참고하였다.\n\nDependencies\n\npandas\nrpy2\ntzlocal\nbiopython\nReportLab\npytest-cov\nbioconductor-deseq2\ncodecov\n\nInstall Guide\nconda config --add channels defaults\nconda config --add channels bioconda\nconda config --add channels conda-forge\nconda create -q -n diffexpr python=3.6 \\\n    pandas tzlocal rpy2 biopython ReportLab pytest-cov \\\n    bioconductor-deseq2 codecov\nconda activate diffexpr # activate diffexpr environment\nRscript setup.R #to install DESeq2 correctly \npython setup.py install\n\nNote: 여기에서는 MAQC 데이터의 샘플 A와 B에서 ERCC transcript의 일부 예제를 사용하였다. 아래 실습에서 사용된 파일들은 여기에서 확인하실 수 있다.\n\n필요한 패키지 로드…\n\n%load_ext autoreload\n%autoreload 2\nimport pandas as pd \nimport numpy as np\n\n\ndf = pd.read_table('ercc.txt')\ndf.head()\n\n\n\n\n\n\n\n\nid\nA_1\nA_2\nA_3\nB_1\nB_2\nB_3\n\n\n\n\n0\nERCC-00002\n111461\n106261\n107547\n333944\n199252\n186947\n\n\n1\nERCC-00003\n6735\n5387\n5265\n13937\n8584\n8596\n\n\n2\nERCC-00004\n17673\n13983\n15462\n5065\n3222\n3353\n\n\n3\nERCC-00009\n4669\n4431\n4211\n6939\n4155\n3647\n\n\n4\nERCC-00012\n0\n2\n0\n0\n0\n0\n\n\n\n\n\n\n\n그리고 여기에서는 유전자 발현의 정량화된 값이 포함된 테이블(count table)의 샘플을 기반으로 design matrix를 생성한다.\n참고로, 샘플 이름은 pd.DataFrame의 인덱스로 사용해야 한다.\n\nsample_df = pd.DataFrame({'samplename': df.columns}) \\\n        .query('samplename != \"id\"')\\\n        .assign(sample = lambda d: d.samplename.str.extract('([AB])_', expand=False)) \\\n        .assign(replicate = lambda d: d.samplename.str.extract('_([123])', expand=False)) \nsample_df.index = sample_df.samplename\nsample_df\n\n\n\n\n\n\n\n\nsamplename\nsample\nreplicate\n\n\nsamplename\n\n\n\n\n\n\n\nA_1\nA_1\nA\n1\n\n\nA_2\nA_2\nA\n2\n\n\nA_3\nA_3\nA\n3\n\n\nB_1\nB_1\nB\n1\n\n\nB_2\nB_2\nB\n2\n\n\nB_3\nB_3\nB\n3\n\n\n\n\n\n\n\nDESeq2 패키지가 R에서 실행되는 방식과 유사하지만 count table의 유전자 ID인 row.name 대신에 어떤 열이 유전자 ID인지 알려야 한다.\n\nfrom py_deseq import py_DESeq2\n\ndds = py_DESeq2(count_matrix = df,\n               design_matrix = sample_df,\n               design_formula = '~ replicate + sample',\n               gene_column = 'id') # &lt;- telling DESeq2 this should be the gene ID column\n    \ndds.run_deseq() \ndds.get_deseq_result(contrast = ['sample','B','A'])\nres = dds.deseq_result \nres.head()\n\nWARNING:rpy2.rinterface_lib.callbacks:R[write to console]: estimating size factors\n\nWARNING:rpy2.rinterface_lib.callbacks:R[write to console]: estimating dispersions\n\nWARNING:rpy2.rinterface_lib.callbacks:R[write to console]: gene-wise dispersion estimates\n\nWARNING:rpy2.rinterface_lib.callbacks:R[write to console]: mean-dispersion relationship\n\nWARNING:rpy2.rinterface_lib.callbacks:R[write to console]: final dispersion estimates\n\nWARNING:rpy2.rinterface_lib.callbacks:R[write to console]: fitting model and testing\n\nINFO:DESeq2:Using contrast: ['sample', 'B', 'A']\n\n\n\n\n\n\n\n\n\nbaseMean\nlog2FoldChange\nlfcSE\nstat\npvalue\npadj\nid\n\n\n\n\nERCC-00002\n167917.342729\n0.808857\n0.047606\n16.990537\n9.650176e-65\n1.102877e-63\nERCC-00002\n\n\nERCC-00003\n7902.634073\n0.521731\n0.058878\n8.861252\n7.912104e-19\n4.868987e-18\nERCC-00003\n\n\nERCC-00004\n10567.048228\n-2.330122\n0.055754\n-41.792764\n0.000000e+00\n0.000000e+00\nERCC-00004\n\n\nERCC-00009\n4672.573043\n-0.195660\n0.061600\n-3.176286\n1.491736e-03\n3.616329e-03\nERCC-00009\n\n\nERCC-00012\n0.384257\n-1.565491\n4.047562\n-0.386774\n6.989237e-01\nNaN\nERCC-00012\n\n\n\n\n\n\n\n\ndds.normalized_count() #DESeq2 normalized count\n\nINFO:DESeq2:Normalizing counts\n\n\n\n\n\n\n\n\n\nA_1\nA_2\nA_3\nB_1\nB_2\nB_3\nid\n\n\n\n\nERCC-00002\n115018.353297\n122494.471246\n128809.545168\n218857.357008\n207880.854689\n214443.474968\nERCC-00002\n\n\nERCC-00003\n6949.952086\n6209.970889\n6305.915138\n9133.911628\n8955.740754\n9860.313944\nERCC-00003\n\n\nERCC-00004\n18237.045763\n16119.180051\n18518.909755\n3319.456296\n3361.532701\n3846.164804\nERCC-00004\n\n\nERCC-00009\n4818.014297\n5107.922964\n5043.534405\n4547.622357\n4334.937422\n4183.406812\nERCC-00009\n\n\nERCC-00012\n0.000000\n2.305540\n0.000000\n0.000000\n0.000000\n0.000000\nERCC-00012\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nERCC-00164\n2.063831\n1.152770\n5.988523\n3.276857\n1.043306\n2.294163\nERCC-00164\n\n\nERCC-00165\n269.329992\n246.692736\n287.449123\n513.811202\n484.094095\n489.803869\nERCC-00165\n\n\nERCC-00168\n1.031916\n3.458309\n0.000000\n4.587600\n4.173225\n1.147082\nERCC-00168\n\n\nERCC-00170\n137.244785\n148.707304\n135.340629\n26.870229\n10.433062\n32.118286\nERCC-00170\n\n\nERCC-00171\n8707.304484\n9622.169484\n8818.699555\n7691.439109\n7691.253592\n6892.813691\nERCC-00171\n\n\n\n\n92 rows × 7 columns\n\n\n\n\ndds.comparison # show coefficients for GLM\n\n['Intercept', 'replicate_2_vs_1', 'replicate_3_vs_1', 'sample_B_vs_A']\n\n\n\n# from the last cell, we see the arrangement of coefficients, \n# so that we can now use \"coef\" for lfcShrink\n# the comparison we want to focus on is 'sample_B_vs_A', so coef = 4 will be used\nlfc_res = dds.lfcShrink(coef=4, method='apeglm')\nlfc_res.head()\n\nWARNING:rpy2.rinterface_lib.callbacks:R[write to console]: using 'apeglm' for LFC shrinkage. If used in published research, please cite:\n    Zhu, A., Ibrahim, J.G., Love, M.I. (2018) Heavy-tailed prior distributions for\n    sequence count data: removing the noise and preserving large differences.\n    Bioinformatics. https://doi.org/10.1093/bioinformatics/bty895\n\n\n\n\n\n\n\n\n\n\nid\nbaseMean\nlog2FoldChange\nlfcSE\npvalue\npadj\n\n\n\n\n0\nERCC-00002\n167917.342729\n0.807316\n0.047609\n9.650176e-65\n1.102877e-63\n\n\n1\nERCC-00003\n7902.634073\n0.519944\n0.058823\n7.912104e-19\n4.868987e-18\n\n\n2\nERCC-00004\n10567.048228\n-2.328037\n0.055783\n0.000000e+00\n0.000000e+00\n\n\n3\nERCC-00009\n4672.573043\n-0.194594\n0.061466\n1.491736e-03\n3.616329e-03\n\n\n4\nERCC-00012\n0.384257\n-0.052326\n0.820696\n6.989237e-01\nNaN\n\n\n\n\n\n\n\n\n\n\n\n라이센스https://creativecommons.org/licenses/by/4.0/deed.ko"
  },
  {
    "objectID": "posts/2023-02-28-Python-libraries-for-genomic-analysis/index.html",
    "href": "posts/2023-02-28-Python-libraries-for-genomic-analysis/index.html",
    "title": "유전체 분석을 위한 파이썬 라이브러리 소개",
    "section": "",
    "text": "생물정보학 분야에서 유전체 분석을 위해 파이썬은 매우 유용한 언어 중 하나입니다.(R도 정말 유용합니다.) 파이썬이 데이터 분석, 머신 러닝, 딥 러닝 등 다양한 분야에서 활용될 수 있기 때문입니다. 또한, 파이썬은 다양한 생물학 데이터를 처리하고 시각화하는 데 매우 효과적입니다. 이번 포스팅에서는 유전체 분석을 위해 유용한 파이썬 라이브러리 몇 가지를 소개합니다.\n\n소개되는 라이브러리는 목차를 참고해주세요."
  },
  {
    "objectID": "posts/2023-02-28-Python-libraries-for-genomic-analysis/index.html#intro",
    "href": "posts/2023-02-28-Python-libraries-for-genomic-analysis/index.html#intro",
    "title": "유전체 분석을 위한 파이썬 라이브러리 소개",
    "section": "",
    "text": "생물정보학 분야에서 유전체 분석을 위해 파이썬은 매우 유용한 언어 중 하나입니다.(R도 정말 유용합니다.) 파이썬이 데이터 분석, 머신 러닝, 딥 러닝 등 다양한 분야에서 활용될 수 있기 때문입니다. 또한, 파이썬은 다양한 생물학 데이터를 처리하고 시각화하는 데 매우 효과적입니다. 이번 포스팅에서는 유전체 분석을 위해 유용한 파이썬 라이브러리 몇 가지를 소개합니다.\n\n소개되는 라이브러리는 목차를 참고해주세요."
  },
  {
    "objectID": "posts/2023-02-28-Python-libraries-for-genomic-analysis/index.html#biopython",
    "href": "posts/2023-02-28-Python-libraries-for-genomic-analysis/index.html#biopython",
    "title": "유전체 분석을 위한 파이썬 라이브러리 소개",
    "section": "Biopython",
    "text": "Biopython\nBiopython은 파이썬에서 생물학 데이터를 처리하는 데 사용되는 강력한 라이브러리입니다. 이 라이브러리는 DNA, RNA 및 단백질 시퀀스 데이터와 관련된 다양한 작업을 수행할 수 있습니다. 예를 들어, 시퀀스를 로드하고 저장하거나, BLAST, Clustal 및 BLAT과 같은 다양한 시퀀스 정렬 및 유사성 검색 도구를 사용할 수 있습니다.(실제로 기능이 매우 많아서 꼭 한번 살펴보시길 바랍니다.)\nBiopython을 사용하면 시퀀스를 다루는 것 외에도, 파일 입출력, 의생명데이터베이스 쿼리, 그리고 시퀀스 시각화 등 다양한 작업을 수행할 수 있습니다. Biopython은 파이썬 2.x 및 3.x 버전을 지원하며, 다양한 운영체제에서 사용할 수 있습니다.\nBiopython은 생물정보학 분야에서 다양한 연구에 활용될 수 있는 매우 방대하고 유용한 라이브러리입니다. 하지만, 이러한 방대한 기능을 활용하기 위해서는 파이썬 프로그래밍에 대한 기초적인 이해와 함께, 생물학적 지식도 함께 필요합니다.\n# Biopython을 이용하여 FASTA 파일을 읽어들이는 예시 코드\nfrom Bio import SeqIO\n\nrecords = SeqIO.parse(\"example.fasta\", \"fasta\")\nfor record in records:\n    print(record.id)\n뿐만 아니라, DNA 서열의 역상보 및 상보 서열을 계산하거나, 서열 정렬, 다양한 서열 데이터베이스와의 상호작용 등을 지원합니다. 또한, 유전체 서열 분석을 위한 다양한 알고리즘, 예를 들면 Smith-Waterman 알고리즘, Needleman-Wunsch 알고리즘 등을 구현하여 제공합니다.\n또한, Biopython은 유전체 데이터 분석에서 더 나은 가독성과 유지보수성을 제공하기 위해 다양한 파이썬 패키지와 통합되어 있습니다. 예를 들어, Biopython은 NumPy, SciPy, matplotlib, pandas와 같은 다른 데이터 분석 도구들과 함께 사용되어, 유전체 데이터 분석의 다양한 단계에서 효율적으로 활용될 수 있습니다.\n하지만, Biopython은 굉장히 방대한 라이브러리이기 때문에, 이 포스팅에서는 Biopython의 일부 기능만 소개하겠습니다. 자세한 내용은 Biopython 공식 홈페이지를 참고하시기 바랍니다."
  },
  {
    "objectID": "posts/2023-02-28-Python-libraries-for-genomic-analysis/index.html#pyvcf",
    "href": "posts/2023-02-28-Python-libraries-for-genomic-analysis/index.html#pyvcf",
    "title": "유전체 분석을 위한 파이썬 라이브러리 소개",
    "section": "PyVCF",
    "text": "PyVCF\nPyVCF는 파이썬에서 VCF (Variant Call Format) 파일을 다루는 데 사용되는 라이브러리입니다. VCF 파일은 다양한 종류의 유전체 변이 데이터를 저장하는 데 사용됩니다. PyVCF는 VCF 파일의 읽기, 쓰기, 수정 등 다양한 작업을 수행할 수 있습니다.\nPyVCF는 파이썬으로 작성된 오픈 소스 라이브러리이며, VCF 파일을 다루는 데 필요한 다양한 도구와 함수를 제공합니다. 이 라이브러리를 사용하면 VCF 파일의 내용을 쉽게 파싱하고, 각각의 변이 정보에 대한 데이터를 추출하고, 필요한 경우 수정하거나 새로운 VCF 파일을 작성할 수 있습니다.\nVCF 파일은 유전체 변이 정보를 포함하며, 이는 각각의 DNA 염기 서열에서 나타나는 변화를 의미합니다. 이러한 변화는 단일 염기 다형성(SNP), 삽입/삭제(indel), 구조적 변화(예: 염색체 재배열) 등의 다양한 형태로 나타납니다. 이러한 변이 정보는 다양한 유전체 연구 분야에서 중요한 역할을 합니다.\nPyVCF는 VCF 파일에서 각각의 변이 정보를 파싱하여 쉽게 접근할 수 있는 객체로 만들어 줍니다. 이러한 객체는 각각의 변이 정보에 대한 다양한 속성과 메서드를 제공하며, 필요한 경우 다른 라이브러리와 연동하여 유전체 데이터 분석을 수행할 수 있습니다.\n또한 PyVCF는 VCF 파일의 내용을 필요에 따라 수정하거나, 새로운 VCF 파일을 생성하는 기능도 제공합니다. 이를 통해 유전체 데이터 분석에서 필요한 전처리 작업을 효율적으로 수행할 수 있습니다.\n최근에는 PyVCF 라이브러리의 개발이 중단되었으나, 여전히 많은 유전체 연구자들이 이를 사용하고 있으며, 파이썬 기반의 유전체 데이터 분석에서 필수적인 도구 중 하나입니다.\nPyVCF 라이브러리를 사용하여 VCF 파일을 읽고, VCF 파일의 정보를 파싱하는 간단한 예시 코드를 몇 가지 알려드리겠습니다.\n\n1. VCF 파일 읽기\nimport vcf\n\n# VCF 파일을 열어서 파서 객체 생성\nvcf_reader = vcf.Reader(open('example.vcf', 'r'))\n\n# 각각의 변이 정보에 대한 객체를 순회하며 출력\nfor record in vcf_reader:\n    print(record)\n\n\n2. 필드에 대한 정보 추출\nimport vcf\n\n# VCF 파일을 열어서 파서 객체 생성\nvcf_reader = vcf.Reader(open('example.vcf', 'r'))\n\n# 각각의 변이 정보에 대한 객체를 순회하며 필요한 필드 정보 추출\nfor record in vcf_reader:\n    # CHROM 필드: 변이가 발생한 염색체 이름\n    chrom = record.CHROM\n    # POS 필드: 변이가 발생한 위치\n    pos = record.POS\n    # REF 필드: 원래 염기 서열\n    ref = record.REF\n    # ALT 필드: 변이된 염기 서열\n    alt = record.ALT\n    # QUAL 필드: 변이가 발생한 신뢰도\n    qual = record.QUAL\n    # INFO 필드: 추가적인 변이 정보\n    info = record.INFO\n    \n    # 필요한 정보를 이용하여 다양한 분석 수행 가능\n    print(chrom, pos, ref, alt, qual, info)\n\n\n3. 필드 정보 수정 및 VCF 파일 쓰기\nimport vcf\n\n# VCF 파일을 열어서 파서 객체 생성\nvcf_reader = vcf.Reader(open('example.vcf', 'r'))\n\n# 변이 정보 수정 후, 새로운 VCF 파일에 쓰기\nvcf_writer = vcf.Writer(open('new_example.vcf', 'w'), vcf_reader)\n\nfor record in vcf_reader:\n    # 필요한 필드 정보 수정\n    record.QUAL = 99.0\n    record.INFO['DP'] = 30\n    \n    # 수정된 객체를 새로운 VCF 파일에 쓰기\n    vcf_writer.write_record(record)\n\nvcf_writer.close()\n위 코드들은 각각 VCF 파일을 읽고, 필드 정보를 추출하거나 수정하며, 새로운 VCF 파일에 정보를 쓰는 예시 코드입니다. PyVCF는 이 외에도 다양한 함수와 기능을 제공하므로, 필요에 따라 다양한 분석 작업을 수행할 수 있습니다.\n# PyVCF를 이용하여 VCF 파일을 읽어들이는 예시 코드\nimport vcf\n\nvcf_reader = vcf.Reader(open('example.vcf', 'r'))\nfor record in vcf_reader:\n    print(record.CHROM, record.POS, record.REF, record.ALT)"
  },
  {
    "objectID": "posts/2023-02-28-Python-libraries-for-genomic-analysis/index.html#deseq2",
    "href": "posts/2023-02-28-Python-libraries-for-genomic-analysis/index.html#deseq2",
    "title": "유전체 분석을 위한 파이썬 라이브러리 소개",
    "section": "DESeq2",
    "text": "DESeq2\nDESeq2는 R 언어로 작성된 라이브러리이지만, 파이썬의 rpy2라이브러리를 사용해서 파이썬에서도 사용할 수 있습니다. 이 라이브러리는 RNA 시퀀싱 데이터를 처리하고, 발현 분석 및 유전자 발현 차이 분석을 수행하는 데 사용됩니다. DESeq2는 매우 정확하고 강력한 통계 기술을 사용하여 RNA 시퀀싱 데이터를 분석하며, 실험 그룹 간의 차이를 식별하는 데 매우 유용합니다.\n# DESeq2를 이용하여 RNA 시퀀싱 데이터를 분석하는 예시 코드\nimport pandas as pd\nimport rpy2.robjects as robjects\nfrom rpy2.robjects import pandas2ri\npandas2ri.activate()\n\n# DESeq2를 R 패키지로부터 로드\ndeseq = robjects.packages.importr('DESeq2')\n\n# 데이터 로드 및 전처리\ncount_table = pd.read_csv('counts.csv')\nmetadata = pd.read_csv('metadata.csv')\n\n# R의 데이터프레임 형식으로 변환\ncount_table_r = pandas2ri.py2ri(count_table)\nmetadata_r = pandas2ri.py2ri(metadata)\n\n# DESeq2 객체 생성\ndds = deseq.DESeqDataSetFromMatrix(countData=count_table_r, colData=metadata_r, design=~group)\n\n# 데이터 분석 수행\ndds = deseq.DESeq(dds)\nres = deseq.results(dds)\n\n# 결과 출력\npandas_result = pandas2ri.ri2py_dataframe(res)\nprint(pandas_result)"
  },
  {
    "objectID": "posts/2023-02-28-Python-libraries-for-genomic-analysis/index.html#pandas",
    "href": "posts/2023-02-28-Python-libraries-for-genomic-analysis/index.html#pandas",
    "title": "유전체 분석을 위한 파이썬 라이브러리 소개",
    "section": "Pandas",
    "text": "Pandas\nPandas는 파이썬에서 데이터 처리를 위해 사용되는 라이브러리입니다. 이 라이브러리는 행과 열로 구성된 데이터 테이블을 다루는 데 매우 유용하며, 대용량 데이터를 처리할 때도 빠르고 효과적입니다. Pandas는 유전체 데이터를 다룰 때도 매우 유용한데, 예를 들어 SNP (Single Nucleotide Polymorphism) 데이터와 같은 유전체 데이터를 다룰 때 많이 사용됩니다. 판다스는 다양한 형식의 데이터(생물학정보를 포함하고 있는)를 가져올 수 있는 기능을 포함하고 있으며, 이러한 데이터를 자유롭게 정리, 필터링, 결합 및 계산하는 데 사용됩니다.\n\n1. 유전체 데이터를 읽기\n유전체 데이터는 대개 큰 파일입니다. 판다스의 read_csv() 함수를 사용하여 CSV 형식의 데이터를 쉽게 읽을 수 있습니다. 유전체 데이터를 읽은 후, 판다스 DataFrame을 사용하여 쉽게 탐색 및 조작할 수 있습니다.\nimport pandas as pd\n\n# 유전체 데이터를 읽기\ndata = pd.read_csv('genetic_data.csv')\n\n# 데이터 확인\nprint(data.head())\n\n\n2. 데이터 필터링\n판다스는 데이터를 쉽게 필터링 할 수 있는 기능을 제공합니다. 예를 들어, 유전체 데이터에서 특정 염색체에 대한 정보만 필터링하려면 다음과 같이합니다.\n# 'chromosome' 열에서 'chr1'만 필터링\nchr1_data = data[data['chromosome'] == 'chr1']\n\n# 필터링된 데이터 확인\nprint(chr1_data.head())\n\n\n3. 데이터 결합\n유전체 데이터는 대개 여러 파일로 나뉘어 있습니다. 이러한 파일을 쉽게 결합하기 위해 판다스의 merge() 함수를 사용할 수 있습니다. 예를 들어, 유전체 데이터와 관련된 표현형 데이터를 결합하는 경우 다음과 같이합니다.\n# 표현형 데이터를 읽기\nphenotype_data = pd.read_csv('phenotype_data.csv')\n\n# 유전체 데이터와 표현형 데이터 결합\nmerged_data = pd.merge(data, phenotype_data, on='sample_id')\n\n# 결합된 데이터 확인\nprint(merged_data.head())\n\n\n4. 데이터 계산\n판다스는 계산 기능을 제공합니다. 예를 들어, 유전체 데이터에서 특정 SNP (single nucleotide polymorphism)에 대한 allele frequency를 계산하려면 다음과 같이합니다.\n# 'allele1_count'와 'allele2_count' 열의 값을 사용하여 'allele_frequency' 열 계산\ndata['allele_frequency'] = data['allele1_count'] / (data['allele1_count'] + data['allele2_count'])\n# 계산된 데이터 확인\nprint(data.head())\n\n\n5. 데이터 시각화\n마지막으로, 판다스는 데이터 시각화를 쉽게 할 수 있는 기능을 제공합니다. 예를 들어, 유전체 데이터의 분포를 확인하려면 다음과 같이합니다.\nimport matplotlib.pyplot as plt\n\n# 'allele_frequency' 열의 분포 확인\ndata['allele_frequency'].plot(kind='hist', bins=20)\n\n# 그래프 제목 설정\nplt.title('Distribution of allele frequency')\n\n# x축 레이블 설정\nplt.xlabel('Allele frequency')\n\n# y축 레이블 설정\nplt.ylabel('Frequency')\n\n# 그래프 표시\nplt.show()\n\n이미지 출처11 Within- and across-breed genomic prediction using whole-genome sequence and single nucleotide polymorphism panels\n이러한 예시를 통해 판다스가 유전체 데이터 분석에서 어떻게 사용되는지 이해할 수 있습니다. 판다스는 데이터 분석 및 시각화에 필수적인 파이썬 라이브러리 중 하나이며, 유전체 데이터와 같은 대용량 데이터를 다룰 때 특히 유용합니다."
  },
  {
    "objectID": "posts/2023-02-28-Python-libraries-for-genomic-analysis/index.html#scikit-learn",
    "href": "posts/2023-02-28-Python-libraries-for-genomic-analysis/index.html#scikit-learn",
    "title": "유전체 분석을 위한 파이썬 라이브러리 소개",
    "section": "Scikit-learn",
    "text": "Scikit-learn\nScikit-learn은 파이썬에서 머신 러닝을 위해 사용되는 라이브러리입니다. 이 라이브러리는 분류, 회귀, 클러스터링 등 다양한 머신 러닝 알고리즘을 제공하며, 데이터 전처리, 특징 추출, 차원 축소 등 다양한 기능을 제공합니다. Scikit-learn은 유전체 데이터 분석에도 매우 유용하며, 예를 들어 SNP 데이터를 사용하여 개체 간의 유전적 차이를 분석하는 데 사용됩니다.(물론 Tensorflow, PyTorch도 유전체 데이터 분석에 사용됩니다.)\nScikit-learn을 사용하면 머신 러닝 모델을 구축하고, 학습시키고, 예측하며, 모델 성능을 평가할 수 있습니다. 또한, 다양한 머신 러닝 알고리즘을 비교하여 가장 적합한 알고리즘을 선택하는 데도 매우 유용합니다.\nScikit-learn은 다양한 머신 러닝 모델을 제공합니다. 그 중에서도 가장 일반적으로 사용되는 모델은 다음과 같습니다.\n\nDecision Tree\nRandom Forest\nSupport Vector Machine (SVM)\nK-Nearest Neighbors (KNN)\nLogistic Regression\nGradient Boosting\nNeural Networks"
  },
  {
    "objectID": "posts/2023-02-28-Python-libraries-for-genomic-analysis/index.html#outro",
    "href": "posts/2023-02-28-Python-libraries-for-genomic-analysis/index.html#outro",
    "title": "유전체 분석을 위한 파이썬 라이브러리 소개",
    "section": "Outro",
    "text": "Outro\n이상으로, 유전체 분석을 위한 파이썬 라이브러리 소개에 대한 포스팅을 마치겠습니다.\n파이썬은 대용량 유전체 데이터를 다루는 데 매우 효율적인 도구로 자리 잡고 있습니다. 이러한 파이썬 라이브러리들을 사용하면, 유전체 데이터를 다양한 관점에서 분석할 수 있으며, 머신 러닝 모델을 구축하여 예측 모델을 개발할 수 있습니다. 이러한 분석을 통해 개체 간의 유전적 차이를 이해하고, 질병 예측 및 진단, 개인 맞춤형 치료, 각종 생물학적 연구 등 다양한 분야에서 활용할 수 있습니다.\n파이썬 라이브러리들을 사용하여 유전체 데이터를 분석하는 것은 매우 흥미로우며, 파이썬 프로그래밍에 대한 기초적인 이해와 함께, 데이터 분석 및 머신 러닝에 대한 지식을 습득하는 데 큰 도움이 될 것입니다. 또한, 이러한 분석을 통해 파이썬 라이브러리의 활용범위를 넓힐 수 있으며, 데이터 과학 및 인공지능 분야에서 적극적인 역할을 할 수 있습니다."
  },
  {
    "objectID": "posts/2022-11-13-what-is-p-value/index.html",
    "href": "posts/2022-11-13-what-is-p-value/index.html",
    "title": "p-value(유의 확률)란 무엇인가?",
    "section": "",
    "text": "머신러닝, 또는 통계관련된 문서, 논문을 보다 보면 p-value라는 말이 꼭 나온다. p-value란 무엇일까. 왜 사용하는 것인가. 오늘은 p-value에 대해서 정리해보고자 한다.\n본 포스팅에서는:"
  },
  {
    "objectID": "posts/2022-11-13-what-is-p-value/index.html#제-1종-오류",
    "href": "posts/2022-11-13-what-is-p-value/index.html#제-1종-오류",
    "title": "p-value(유의 확률)란 무엇인가?",
    "section": "제 1종 오류",
    "text": "제 1종 오류\n귀무가설이 참임에도 불구하고 귀무가설을 기각할 때 발생하는 오류"
  },
  {
    "objectID": "posts/2022-11-13-what-is-p-value/index.html#제-2종-오류",
    "href": "posts/2022-11-13-what-is-p-value/index.html#제-2종-오류",
    "title": "p-value(유의 확률)란 무엇인가?",
    "section": "제 2종 오류",
    "text": "제 2종 오류\n귀무가설이 거짓임에도 볼구하고 귀무가설을 채택하려는 오류\n\n이러한 오류에도 불구하고 귀무가설을 채택할 것인지는, 제 1종 오류를 저지를 확률인 p-value(유의 확률)과 제 1종 오류가 발생할 확률인 유의수준(a)으로 판단한다.\n\n유의수준(a) &gt; 유의확률(p-value) : (1-유의수준) * 100% 신뢰수준에서 귀무가설을 기각한다."
  },
  {
    "objectID": "posts/2022-11-13-what-is-p-value/index.html#억지로-유의하게-만들-수-있다",
    "href": "posts/2022-11-13-what-is-p-value/index.html#억지로-유의하게-만들-수-있다",
    "title": "p-value(유의 확률)란 무엇인가?",
    "section": "억지로 유의하게 만들 수 있다",
    "text": "억지로 유의하게 만들 수 있다\n분석에 사용되는 데이터가 증가할수록 p-value는 작아지게 됩니다. 따라서 0.05보다 작은 p-value가 필요하다면, p-value가 작아질때까지 데이터를 계속 추가하면 됩니다. (즉, 이론적으로는 데이터를 계속 추가하면 p-value가 0이 됩니다)"
  },
  {
    "objectID": "posts/2022-11-13-what-is-p-value/index.html#결국-p-value도-확률값이다",
    "href": "posts/2022-11-13-what-is-p-value/index.html#결국-p-value도-확률값이다",
    "title": "p-value(유의 확률)란 무엇인가?",
    "section": "결국 p-value도 확률값이다",
    "text": "결국 p-value도 확률값이다\n당연하지만 p-value도 지표로 사용되는 확률값일 뿐이다. 절대적인 지표가 아니기 때문에 p-value가 낮다고 무조건 맞는것이 아니다. 항상 통계는 확률을 의미한다는 점을 명심해야한다."
  },
  {
    "objectID": "posts/2022-11-13-what-is-p-value/index.html#p-value의-기준이-왜-0.05인가",
    "href": "posts/2022-11-13-what-is-p-value/index.html#p-value의-기준이-왜-0.05인가",
    "title": "p-value(유의 확률)란 무엇인가?",
    "section": "p-value의 기준이 왜 0.05인가",
    "text": "p-value의 기준이 왜 0.05인가\n통상적으로 기준이 없을 경우 0.05로 쓰는 경향이 있다. 과학에서 통상적인 기준이 가지는 의미가 없다고 말할 순 없지만, 다른 p-value 기준을 사용하게 된다면 그에따른 이유가 분명히 있어야 한다는 점을 강조하고 싶다. 물론, 보통 기준으로 삼는 0.05를 만족할지라도 가설이 맞을 확률이 95%라고 확신할 수는 없다.(p-value를 만족한다고 해서 결과가 중요하다고 의미를 부여해서는 안된다. 이는 첫 번째 한계에서 언급한데로 데이터를 계속 추가하면 p-value가 낮아진다는 점과 같이 고려해보아야 한다.)"
  },
  {
    "objectID": "posts/2021-05-8-NAS-network-drive-mount-on-ubuntu/index.html",
    "href": "posts/2021-05-8-NAS-network-drive-mount-on-ubuntu/index.html",
    "title": "우분투에 NAS 마운트",
    "section": "",
    "text": "우리는 NAS를 사용하면서 데스크탑에 저장할 수 없는 대용량의 자료들을 저장하고는 합니다. 보통 백업의 용도로 사용되는데, 가끔은 외장하드처럼 마운트해서 사용해야 할 때가 있죠. 그래서 여러가지 접속 방법을 사용하여 자신의 PC에 있는 드라이브 처럼 사용할 수 있습니다. 윈도우는 검색하면 많이 나오는데 우분투의 경우에는 많이 없는 것 같아서 기록을 하게 되었습니다."
  },
  {
    "objectID": "posts/2021-05-8-NAS-network-drive-mount-on-ubuntu/index.html#들어가면서",
    "href": "posts/2021-05-8-NAS-network-drive-mount-on-ubuntu/index.html#들어가면서",
    "title": "우분투에 NAS 마운트",
    "section": "",
    "text": "우리는 NAS를 사용하면서 데스크탑에 저장할 수 없는 대용량의 자료들을 저장하고는 합니다. 보통 백업의 용도로 사용되는데, 가끔은 외장하드처럼 마운트해서 사용해야 할 때가 있죠. 그래서 여러가지 접속 방법을 사용하여 자신의 PC에 있는 드라이브 처럼 사용할 수 있습니다. 윈도우는 검색하면 많이 나오는데 우분투의 경우에는 많이 없는 것 같아서 기록을 하게 되었습니다."
  },
  {
    "objectID": "posts/2021-05-8-NAS-network-drive-mount-on-ubuntu/index.html#환경",
    "href": "posts/2021-05-8-NAS-network-drive-mount-on-ubuntu/index.html#환경",
    "title": "우분투에 NAS 마운트",
    "section": "환경",
    "text": "환경\n알아야 할 정보들:\n\nNAS IP\nNAS access ID\nNAS access PW\n마운트할 nas 경로\n마운트할 local 경로"
  },
  {
    "objectID": "posts/2021-05-8-NAS-network-drive-mount-on-ubuntu/index.html#methods",
    "href": "posts/2021-05-8-NAS-network-drive-mount-on-ubuntu/index.html#methods",
    "title": "우분투에 NAS 마운트",
    "section": "Methods",
    "text": "Methods\n\n1. 패키지 설치\n마운트를 하기 위한 패키지 설치 단계로 cifs-utils를 설치해주어야 합니다.\nsudo apt-get install cifs-utils\n\n\n2. 마운트 하기 위한 폴더 생성\nNAS를 현재 우분투의 경로에 마운트를 해 주어야 하는데, 그러기 위해 폴더를 생성해줍니다.\nmkdir /mnt/nas-drive\n# /mnt/nas-drive 루트 경로에 추가하기 위해서는 sudo 권한이 필요할 것이며,\n# 자신의 디렉토리에 폴더를 생성해서 마운트도 가능합니다.\n\n\n3. 네트워크 드라이브 연결 (마운트)\n아래와 같은 형식으로 입력을 해주어야 합니다. 마지막에 위치하는 vers=1.0 을 입력해주어야 저는 에러가 나지 않더라구요.\nsudo mount -t cifs //{NAS drive IP}/{NAS directory path} {local path} -o user='NAS ID',password='NAS PW',rw,vers=1.0\n예를 들어:\n\nNAS IP : 111.11.11.111\nNAS access ID : admin\nNAS access PW : admin\n마운트할 nas 경로 : /home\n마운트할 local 경로 : /mnt/nas-drive\n\n라는 환경이라면\nsudo mount -t cifs //111.11.11.111/home /mnt/nas-drive -o user='admin',password='admin',rw,vers=1.0\n가 되겠죠?\n\n\n4. 자동 마운트 등록\n4번을 진행하지 않는다면 재부팅 후에는 마운트가 끊어집니다. 계속 연결이 되어야 한다면 fstab 에 등록을 해주어서 부팅할 때마다 마운트 하도록 하면 됩니다.\nsudo vim /etc/fstab\n\n//111.11.11.111/home /mnt/nas-drive cifs user='admin',password='admin',rw,vers=1.0  0   0"
  },
  {
    "objectID": "posts/2023-03-29-which-reference-genome-should-i-use/index.html",
    "href": "posts/2023-03-29-which-reference-genome-should-i-use/index.html",
    "title": "어떤 reference genome을 사용해야 할까?",
    "section": "",
    "text": "이 포스팅은 Tutorial: Which human reference genome should I use? 에 있는 포스팅을 번역한 내용이 포함되어있습니다. 오역이나 의역이 있을 수 있습니다. 지적해주시면 확인 후에 정정하겠습니다.\nOriginal source of this posting is form Tutorial: Which human reference genome should I use? If the original author requests deletion, it will be deleted immediately.\n\n\n“어떤 reference genome을 선택해야 하는가?”는 biostas에서 나오는 상위권 질문들중 하나입니다. 이 질문에 대한 답은 꽤 쉬워보입니다: 가장 최신의 major 버전(GRCh38)을 가져오는 것입니다.(Genome Reference Consortium)\n그러나 genome 파일을 다운로드 하러가기 전에 다음 질문들이 명확해야 합니다:\n\n이전 버전을 사용해야 하는 이유는 무엇인가?\nreference fasta 에는 어떤 서열정보가 포함되어 있는가?\n최신 마이너 버전의 사용은 어떤가?\n정렬(alignment)을 위해 reference fasta를 준비하려면 어떤 단계들이 필요한가?"
  },
  {
    "objectID": "posts/2023-03-29-which-reference-genome-should-i-use/index.html#이전-버전을-사용해야-하는-이유는-무엇인가",
    "href": "posts/2023-03-29-which-reference-genome-should-i-use/index.html#이전-버전을-사용해야-하는-이유는-무엇인가",
    "title": "어떤 reference genome을 사용해야 할까?",
    "section": "1. 이전 버전을 사용해야 하는 이유는 무엇인가?",
    "text": "1. 이전 버전을 사용해야 하는 이유는 무엇인가?\n시작하기 전에 실험에 사용할 데이터베이스를 확인합니다. 최근 assembly에 대한 데이터 접근이 가능한지? 해당 데이터를 아직 사용할 수 없는 경우 데이터를 최신 버전으로 옮기려면 얼마나 큰 노력을 기울여야 하는지?"
  },
  {
    "objectID": "posts/2023-03-29-which-reference-genome-should-i-use/index.html#reference-fasta-에는-어떤-서열정보가-포함되어-있는가",
    "href": "posts/2023-03-29-which-reference-genome-should-i-use/index.html#reference-fasta-에는-어떤-서열정보가-포함되어-있는가",
    "title": "어떤 reference genome을 사용해야 할까?",
    "section": "2. reference fasta 에는 어떤 서열정보가 포함되어 있는가?",
    "text": "2. reference fasta 에는 어떤 서열정보가 포함되어 있는가?\n최신 메이저 릴리즈 파일은 다음과 같습니다: ftp://ftp.ncbi.nlm.nih.gov/genomes/all/GCA/000/001/405/GCA_000001405.28_GRCh38.p13 (2020/01/14 기준)\n서열은 GCA_000001405.28_GRCh38_genomic.fna.gz 에 있습니다.\n이 파일은 다음의 서열정보를 포함합니다.\n\nchromosomes 1-22, X, Y\nsequences that can be asigned to one chromosome, but not to an exact position or orientation (unlocalized sequences)\nsequences that cannot be assigned to any chromosome (unplaced sequences)\nthe mitochondrial genome\nsequences that provides an alternate representation of a locus (alernate locus)\n\n(1)-(3) build together the so-called Primary Assembly."
  },
  {
    "objectID": "posts/2023-03-29-which-reference-genome-should-i-use/index.html#최신-마이너-버전의-사용은-어떤가",
    "href": "posts/2023-03-29-which-reference-genome-should-i-use/index.html#최신-마이너-버전의-사용은-어떤가",
    "title": "어떤 reference genome을 사용해야 할까?",
    "section": "3. 최신 마이너 버전의 사용은 어떤가?",
    "text": "3. 최신 마이너 버전의 사용은 어떤가?\n.p&lt;version-number&gt; 라고 나타나는 마이너 버전을 알 수 있을 것입니다. 최신 버전은 GRCh38.p13.입니다. (2020/01/14 기준) 그런데 제가 왜 이 버전의 링크를 제공하지 않았을까요?\n마이너 버전의 서열들은 메이저 버전에서 untouch 되었습니다. 대신에 패치라고 불리는 서열정보가 추가되었습니다(여기서 p가 유래됨.). 이런 패치는 기존 서열의 수정일 수 있으며 다음 메이저 릴리즈 버전의 기본 assembly로 통합될 것입니다. 또는 다음 메이저 릴리즈에서 “alternate loci”라고 하는 새로운 서열을 나타내기도 합니다.\n이 FAQ 에서 패치에 대한 자세한 내용을 읽을 수 있습니다.\n따라서 우리가 특별한 이유가 있지 않은 한, 우리는 정렬(alignment)를 위해 primary assembly 및 mitochondrial genome의 서열을 사용해야 합니다. 그 이유는 다음 챕터에서 말해드리겠습니다."
  },
  {
    "objectID": "posts/2023-03-29-which-reference-genome-should-i-use/index.html#정렬alignment을-위해-reference-패스트를-준비하려면-어떤-단계들이-필요한가",
    "href": "posts/2023-03-29-which-reference-genome-should-i-use/index.html#정렬alignment을-위해-reference-패스트를-준비하려면-어떤-단계들이-필요한가",
    "title": "어떤 reference genome을 사용해야 할까?",
    "section": "4. 정렬(alignment)을 위해 reference 패스트를 준비하려면 어떤 단계들이 필요한가?",
    "text": "4. 정렬(alignment)을 위해 reference 패스트를 준비하려면 어떤 단계들이 필요한가?\n\n이 부분에 설명하는 대부분의 내용들은 Heng Li 의 블로그 포스트에서 영감을 받았습니다. (Heng Li는 우리가 잘 알고있는 bwa 와 samtools 의 개발자입니다.)\n\n위에 링크된 reference sequence는 다음 세 가지 이유로 정렬(alignment)에 사용할 준비가 되어있지 않습니다:\n\nloci의 alternate represnetation이 포함됩니다. 이것들은 primary assembly와 매우 유사한데, 그렇기 때문에 대부분의 정렬(alignment)에서는 reads 위치를 알지 못하고 mapping 품질이 매우 낮습니다(variant calling에는 좋지 않다는 걸 의미합니다.).\n염색체 Y에는 유사 염색체 X에 위치한 영역의 복제인 pseudo-autosomal region(PAR)이 있습니다. 이것 또한 정렬(alignment)에서 read의 위치를 알지 못합니다.\n서열들이 1 이라는 이름 대신에 CM000663.2 라는 GeneBank Accesion Numbers 를 가지고 있습니다.\n\n(1)에서 보여지는 불분명한 mapping은 (2)에서 패치 서열에서도 유효합니다. 이건 우리가 정렬(alignment)을 할 때 최신 마이너 버전을 사용할 필요가 없는 이유입니다.\n그래서 우리는 이렇게 해야합니다:\n\nGRC로부터 제공되는 서열들의 서브셋을 구축\n염색체 Y의 PAR을 표시\n서열 이름 바꾸기\n\n이러한 일들을 하기 위해서 우리는 몇가지 파일들이 필요합니다:\n\n서브셋을 구축하고 서열 이름을 바꾸기 위해 GCA_000001405.28_GRCh38.p13_assembly_report.txt\nPAR을 표시하기 위해 par_align.gff\n\n\n\nGRC로부터 제공되는 서열들의 서브셋 구축\nreference sequence 를 다운로드 한 후에 압축을 풀고 samtools faidx 로 인덱스한다:\n$ samtools faidx GCA_000001405.28_GRCh38.p13_genomic.fna\nGCA_000001405.28_GRCh38.p13_assembly_report.txt 에서 primary assembly들과 mitochondrial genome의 이름들을 추출해야 합니다. 많은 bioinformatic tool들이 서열들이 정리되었다 여깁니다. 따라서 현재 이름을 나중에 사용하려는 서열 이름으로 정렬해야 합니다.\n$ sort -k1,1V GCA_000001405.28_GRCh38.p13_assembly_report.txt|awk -v FS=\"\\t\" '$8 == \"Primary Assembly\" || $8 == \"non-nuclear\" {print $5}' &gt; subset_ids.txt\n이 목록을 사용하여 서열의 서브셋을 구축할 수 있습니다.\n\n\n\n염색체 Y의 PAR을 표시\npar_align.gff 에는 PAR이 X염색체에 있고 그것에 맞먹는 것들이 Y 염색체에 있다는 정보가 들어있습니다. 파일을 열고 각 라인에서 Target 키워드를 찾아보세요. 값은 우리가 마스크하고 싶은 Y 염색체의 위치입니다. 이렇게 하려면 이러한 값을 가진 bed 파일을 우리가 만들어야 합니다(주의 : gff 는 1-based position이며 bed 는 0-based입니다). 우리는 이렇게 하면 됩니다.\n$ cat parY.bed\nCM000686.2  10000   2781479\nCM000686.2  56887902    57217415\nbed 파일을 가져오는 한 줄짜리 코드:\n$ sed -E 's/.*Target=([^;]+).*/\\1/g' par_align.gff|awk -v OFS=\"\\t\" '$0 !~ \"^#\" {print $1, $2-1, $3}'  &gt; parY.bed\nbedtools 를 가지고 표시할 수도 있습니다:\n$ bedtools maskfasta -fi GRCh38_subset.fa -bed parY.bed -fo GRCh38_subset_masked.fa\n\n\n\n서열 이름 바꾸기\n최근에는 각각의 서열들의 헤더는 다음과 같습니다:\n&gt; CM000663.2\n우리가 좋아하는 것은 이렇게 하는 겁니다:\n&gt;1 CM000663.2 NC_000001.11 chr1\n첫 공백까지 오는 건 모두 ID가 됩니다. 그 뒤에 오는건 정보가 됩니다.\n$ awk -v FS=\"\\t\" 'NR==FNR {header[\"&gt;\"$5] = \"&gt;\"$1\" \"$5\" \"$7\" \"$10; next} $0 ~ \"^&gt;\" {$0 = header[$0]}1' GCA_000001405.28_GRCh38.p13_assembly_report.txt GRCh38_subset_masked.fa &gt; GRCh38_alignment.fa\n\n\n\n인덱싱\n이제 GRCh38_alignment.fa 는 정렬에 사용할 준비가 되었습니다. 다른 tool들이 필요로 하기 때문에, 저는 이 파일을 samtools faidx 로 인덱스 하기를 추천합니다. 또한 사용하려는 alignment tool에 설명된 방식으로 인덱싱 해야합니다. 예를 들어 bwa 라면 : bwa index GRCh38_alignment.ga"
  },
  {
    "objectID": "posts/2021-04-27-python-funtions/index.html",
    "href": "posts/2021-04-27-python-funtions/index.html",
    "title": "보통은 잘 모르는 파이썬 내장함수 3가지",
    "section": "",
    "text": "파이썬의 기본을 한 번 끝낸 후, 조금 더 심화된 파이썬 문법을 필요로 한다면 배워볼 수 있는 문법들입니다. 중급 문법들은 파이썬을 조금 더 쉽게 작성할 수 있도록 도와주고 불필요한 반복을 없애주죠.\n이번 시간에는 map, filter, reduce에 대해 배워볼건데, 이 3가지 함수들은 list를 다루는 함수입니다. 물론 기본 문법에서 배운 것처럼 이 3가지 함수를 사용하지 않아도 코딩하는 것에는 문제가 없습니다. 하지만 저의 경우에는 아래의 3가지 함수를 통해 반복문을 덜 사용하게 되었고, 불필요한 함수를 따로 만들어줄 필요가 없어서 편했습니다.\n자 그러면 시작해볼까요?"
  },
  {
    "objectID": "posts/2021-04-27-python-funtions/index.html#map",
    "href": "posts/2021-04-27-python-funtions/index.html#map",
    "title": "보통은 잘 모르는 파이썬 내장함수 3가지",
    "section": "map",
    "text": "map\nmap 은 리스트의 각 요소들을 지정된 함수로 처리하는 기능을 합니다. 쉽게 말하면 A라는 함수가 있고 list B가 있다면 A함수를 B로 수행한 결과를 돌려주는 거라고 할 수 있습니다.\n먼저 for 반복문을 사용하여 정수가 저장된 리스트를 제곱하고 2로 나누어 볼까요?\na = [1, 2, 3, 4]\nresult = []\n\nfor i in range(len(a)):\n    result.append(a[i] ** 2 / 2)\n\nprint(result)\n1, 2, 3, 4의 정수 리스트를 받아 제곱을 해주고 2로 나눠주는 코드입니다. 간단하죠? 실행 결과는 다음과 같습니다.\n\n결과 : [0.5, 2.0, 4.5, 8.0]\n\n이 예제를 map 함수를 사용해볼까요?\na = [1, 2, 3, 4]\n\nprint(list(map(lambda x: x**2/2, a)))\n똑같이 4개의 정수를 각 element를 받아 제곱을 해주고 2로 나눠주는 코드입니다. map 함수 앞에서 list 함수를 통해 list 자료형으로 변환하는 이유는 map 함수의 반환이 list가 아니기 때문인데요. Iterator 로 반환하는 값을 list로 변환하는 것입니다.(Iterator에 대해서는 다음에 따로 글을 써보겠습니다.)"
  },
  {
    "objectID": "posts/2021-04-27-python-funtions/index.html#filter",
    "href": "posts/2021-04-27-python-funtions/index.html#filter",
    "title": "보통은 잘 모르는 파이썬 내장함수 3가지",
    "section": "filter",
    "text": "filter\n정의 : 무엇을 걸러내다.\n실제 filter 함수의 쓰임도 정의와 같습니다. filter 은 A라는 함수에 대해 리스트 B의 element 중 참에 해당하는 값을 돌려주는 것이라고 할 수 있습니다.\na = [-3, -2, -1, 0, 1, 2, 3]\n\nprint(list(filter(lambda x: x&gt;0, a)))\n-3에서 3까지의 정수중에서 0보다 큰 값을 돌려주는 코드입니다. 참 쉽죠?\n 이 방법이 괜찮은데? \n하지만 꼭 이 방법만을 써야하는건 아닙니다. 우리에게는 list comprehension 이 있습니다.\nmap 함수를 list comprehension으로 구현해 볼까요?\na = [1, 2, 3, 4]\n\nprint([x**2/2 for x in a])\n오히려 더 간결한 것 같기도 하고..\nfilter 함수도 마찬가지입니다.\na = [-3, -2, -1, 0, 1, 2, 3]\n\nprint([x for x in a if x&gt;0])\n이처럼 방금 배운 map과 filter가 마음에 들지 않으면 list comprehension을…쓸 수도 있습니다."
  },
  {
    "objectID": "posts/2021-04-27-python-funtions/index.html#reduce",
    "href": "posts/2021-04-27-python-funtions/index.html#reduce",
    "title": "보통은 잘 모르는 파이썬 내장함수 3가지",
    "section": "reduce",
    "text": "reduce\nreduce 는 원래는 내장함수였는데 python 3부터 내장함수에서 빠지고 functools에서 가져와야 합니다.\nreduce에 대한 원리는 그림 한장으면 끝납니다.\n\n아이큐 테스트같지만 1부터 5까지 차례대로 더하는 거라는 걸 알 수 있겠죠? 수식으로 표현해 본다면 다음과 같습니다.\n((((1+2)+3)+4)+5)\n코드로 작성해 보면 아래와 같습니다.\nfrom functools import reduce\n\na = [1, 2, 3, 4, 5]\n\nprint(reduce(lambda x, y: x+y, a))\nreduce 함수의 경우에는 list comprehension로 대체할 수 없습니다. 이유는 reduce 함수는 2 element가 입력으로 들어가게 되는데 list comprehension은 2가지 입력을 받지 못하기 때문입니다."
  },
  {
    "objectID": "posts/2023-03-29-what-is-RPKM-FPKM-TPM/index.html",
    "href": "posts/2023-03-29-what-is-RPKM-FPKM-TPM/index.html",
    "title": "RPKM, FPKM, TPM이 무엇인가?",
    "section": "",
    "text": "생물 정보학에서 굉장히 흔하게 접할 수 있는 용어 중 하나로 RPKM, FPKM, TPM이 있습니다.\nRNA-seq의 발현 분석에서 normalized gene expression을 의미하는 것으로 초창기에는 RPKM이 많이 쓰였으나 FPKM을 거쳐 현재에는 TPM을 주로 사용하고 있습니다. (FPKM 또한 많이 사용중)\n따라서 이 3가지 값을 계산하는 방법을 소개하려고 합니다. 아래 순서대로 이해하시면 됩니다.\n먼저 A, B, C, D라는 4개의 gene과 3개의 replicate를 가지고 있는 테이블이 있습니다.\ngene 옆에 있는 kb(kilobase)는 gene의 길이입니다.\n\n\n\n\n\nGene Name\n\n\nRep1 Counts\n\n\nRep2 Counts\n\n\nRep3 Counts\n\n\n\n\n\n\nA (2kb)\n\n\n10\n\n\n12\n\n\n30\n\n\n\n\nB (4kb)\n\n\n20\n\n\n25\n\n\n60\n\n\n\n\nC (1kb)\n\n\n5\n\n\n8\n\n\n15\n\n\n\n\nD (10kb)\n\n\n0\n\n\n0\n\n\n1\n\n\n\n\n\nRep3를 보면 gene에 상관없이 다른 replicate들보다 많은 reads를 가진 것을 알 수 있습니다. 이는 sequencing depth가 다른 replicate들보다 높다는 걸 의미합니다. 이제 이걸 normalize(정규화) 할 것입니다.\n또한 gene B는 gene A에 2배에 해당하는 ’길이’를 가지고 있고, 이건 replicate에 상관없이 2배 많은 reads를 가지고 있다는 것을 설명하는 것일 수도 있습니다. 우리는 이것도 정규화해보려고 합니다.\n\nRPKM\nRPKM은 single-end RNA-seq용으로 제작되었습니다. 먼저 사자성어 풀이하듯 각 알파벳의 의미를 먼저 살펴보겠습니다. Reads Per Kilobase per Millions mapped reads\n그러면 이게 무슨 뜻이냐…하면 전체 유전자의 길이를 Kilobase(=1000 base pair)로 정규화했을 때 전체 reads 중에서 해당 gene에 mapping된 reads들을 말합니다. 그런데 이 수는 너무 적기 때문에 106을 곱해주게 됩니다.\n즉 FPKM은 total (1)reads에서 gene에 매핑된 리드들 나눈 값, (2) gene의 전체 길이를 1000으로 나눈 값, (3)106을 곱해주면 됩니다.\n\n즉, gene 단위의 expression입니다.\n이해가 잘 안되신다면 직접 계산해볼까요?\n\n\n\n\n\nGene Name\n\n\nRep1 Counts\n\n\nRep2 Counts\n\n\nRep3 Counts\n\n\n\n\n\n\nA (2kb)\n\n\n10\n\n\n12\n\n\n30\n\n\n\n\nB (4kb)\n\n\n20\n\n\n25\n\n\n60\n\n\n\n\nC (1kb)\n\n\n5\n\n\n8\n\n\n15\n\n\n\n\nD (10kb)\n\n\n0\n\n\n0\n\n\n1\n\n\n\n\n\n먼저, (1) read depth를 정규화합니다.\n\n각각의 replicate들에서 총 reads의 수를 계산합니다.\n\n\n\n\n\n\nGene Name\n\n\nRep1 Counts\n\n\nRep2 Counts\n\n\nRep3 Counts\n\n\n\n\n\n\nTotal reads\n\n\n35\n\n\n45\n\n\n106\n\n\n\n\n\n\n이 Total reads를 106으로 나누어야 하는데 보기 쉽게 10으로만 나눠보겠습니다.\n\n\n\n\n\n\nGene Name\n\n\nRep1 Counts\n\n\nRep2 Counts\n\n\nRep3 Counts\n\n\n\n\n\n\nTens of reads\n\n\n3.5\n\n\n4.5\n\n\n10.6\n\n\n\n\n\n따라서 이 값들은 각 replicate들에 대한 “per million” scaling factors입니다. 그러니까 우리는 각 gene의 read counts을 이 값들로 나누어야 합니다. 그러면 우리는 reads per million을 계산할 수 있는데 이를 RPM이라고 해보죠.\n\n\n\n\n\nGene Name\n\n\nRep1 RPM\n\n\nRep2 RPM\n\n\nRep3 RPM\n\n\n\n\n\n\nA (2kb)\n\n\n2.86\n\n\n2.67\n\n\n2.83\n\n\n\n\nB (4kb)\n\n\n5.71\n\n\n5.56\n\n\n5.66\n\n\n\n\nC (1kb)\n\n\n1.43\n\n\n1.78\n\n\n1.42\n\n\n\n\nD (10kb)\n\n\n0\n\n\n0\n\n\n0.09\n\n\n\n\n\n\n두 번째 단계는 (2) gene length로 정규화하는것입니다. 각 replicate의 counts를 gene length(Kilobase)로 나누면 됩니다. 쉽죠? 그러면 아래의 테이블이 나오게 됩니다.\n\n\n\n\n\nGene Name\n\n\nRep1 RPKM\n\n\nRep2 RPKM\n\n\nRep3 RPKM\n\n\n\n\n\n\nA (2kb)\n\n\n1.43\n\n\n1.33\n\n\n1.42\n\n\n\n\nB (4kb)\n\n\n1.43\n\n\n1.39\n\n\n1.42\n\n\n\n\nC (1kb)\n\n\n1.43\n\n\n1.78\n\n\n1.42\n\n\n\n\nD (10kb)\n\n\n0\n\n\n0\n\n\n0.009\n\n\n\n\n\n자 그러면 우리는 RPKM을 가지게 되었습니다.\n\n정리해볼까요?\n우리는 depth와 gene length을 정규화하지 않은 데이터를 가지고 있었습니다.\n\n\n\n\n\nGene Name\n\n\nRep1 Counts\n\n\nRep2 Counts\n\n\nRep3 Counts\n\n\n\n\n\n\nA (2kb)\n\n\n10\n\n\n12\n\n\n30\n\n\n\n\nB (4kb)\n\n\n20\n\n\n25\n\n\n60\n\n\n\n\nC (1kb)\n\n\n5\n\n\n8\n\n\n15\n\n\n\n\nD (10kb)\n\n\n0\n\n\n0\n\n\n1\n\n\n\n\n\n하지만 우리는 이제 각각의 sequencing depth와 각각의 gene length에 대해 정규화해서 각각의 replicate와 각각의 gene에 대한 RPKM 데이터를 가지게 되었습니다.\n\n\n\n\n\nGene Name\n\n\nRep1 RPKM\n\n\nRep2 RPKM\n\n\nRep3 RPKM\n\n\n\n\n\n\nA (2kb)\n\n\n1.43\n\n\n1.33\n\n\n1.42\n\n\n\n\nB (4kb)\n\n\n1.43\n\n\n1.39\n\n\n1.42\n\n\n\n\nC (1kb)\n\n\n1.43\n\n\n1.78\n\n\n1.42\n\n\n\n\nD (10kb)\n\n\n0\n\n\n0\n\n\n0.009\n\n\n\n\n\n\n\n\n\nFPKM\nRPKM과 유사한 이름을 가지고 있는 FPKM은 Fragment Per Kilobase of transcript per Million mapped reads의 약자입니다. paired-end로 RNA-seq을 하면 하나의 fragment에서 2개의 read가 나옵니다. (RPKM의 무조건 2배가 되는건 아닙니다) 이는 transcript 관점의 expression으로 볼 수 있습니다.\n\nRPKM과 FPKM의 차이점은 FPKM은 두개의 reads가 하나의 fragment에 mapping된다는 점을 고려한다는 것입니다.\n\n\n\nTPM\nTPM은 Transcripts Per Million의 약자로 FPKM, RPKM과 유사한 개념이지만 transcript length의 분포까지 포함한 개념이라고 합니다.\nTPM을 계산하는 방법 아래와 같습니다.\nRPKM / Total RPKM * 10^6\n흠.. 같이 봐볼까요?\n\n\n\n\n\nGene Name\n\n\nRep1 Counts\n\n\nRep2 Counts\n\n\nRep3 Counts\n\n\n\n\n\n\nA (2kb)\n\n\n10\n\n\n12\n\n\n30\n\n\n\n\nB (4kb)\n\n\n20\n\n\n25\n\n\n60\n\n\n\n\nC (1kb)\n\n\n5\n\n\n8\n\n\n15\n\n\n\n\nD (10kb)\n\n\n0\n\n\n0\n\n\n1\n\n\n\n\n\n먼저 (1) 각 replicate의 counts를 gene length로 나눕니다. 그러면 아래의 테이블이 나오겠죠? RPK는 Reads Per Kilobase라는걸 알 수 있습니다.\n\n\n\n\n\nGene Name\n\n\nRep1 RPK\n\n\nRep2 RPK\n\n\nRep3 RPK\n\n\n\n\n\n\nA (2kb)\n\n\n5\n\n\n6\n\n\n15\n\n\n\n\nB (4kb)\n\n\n5\n\n\n6.25\n\n\n15\n\n\n\n\nC (1kb)\n\n\n5\n\n\n8\n\n\n15\n\n\n\n\nD (10kb)\n\n\n0\n\n\n0\n\n\n0.1\n\n\n\n\n\n두 번째 단계로 (2) sequencing depth로 정규화하는 것입니다. 우리가 gene lengh을 정규화한 것들의 합(각 replicate read counts의 합)과 각 replicate의 RPK 수를 합하고 (원래는 10^6으로 나눠야 하지만) 10으로 나눈 Tens of RPK를 사용할 것입니다.\n\n\n\n\n\nGene Name\n\n\nRep1 RPK\n\n\nRep2 RPK\n\n\nRep3 RPK\n\n\n\n\n\n\nTotal RPK\n\n\n15\n\n\n20.25\n\n\n45.1\n\n\n\n\nTens of RPK\n\n\n1.5\n\n\n2.025\n\n\n4.51\n\n\n\n\n\n각 replicate의 counts를 Tens of RPK로 나누게 되면 TPM이 완성됩니다.\n\n\n\n\n\nGene Name\n\n\nRep1 TPM\n\n\nRep2 TPM\n\n\nRep3 TPM\n\n\n\n\n\n\nA (2kb)\n\n\n3.33\n\n\n2.96\n\n\n3.326\n\n\n\n\nB (4kb)\n\n\n3.33\n\n\n3.09\n\n\n3.326\n\n\n\n\nC (1kb)\n\n\n3.33\n\n\n3.95\n\n\n3.326\n\n\n\n\nD (10kb)\n\n\n0\n\n\n0\n\n\n0.02\n\n\n\n\n\n\n\n\n그래서 이게 뭘 의미하는데?\n그렇죠 계산하는 방법만 알면 다가 아니죠. 이 둘(RPKM과 TPM)이 뭐가 다른지 알아야겠지요. RPKM과 TPM을 비교해봅시다.\n\nRPKM\n\n\n\n\n\nGene Name\n\n\nRep1 RPKM\n\n\nRep2 RPKM\n\n\nRep3 RPKM\n\n\n\n\n\n\nA (2kb)\n\n\n1.43\n\n\n1.33\n\n\n1.42\n\n\n\n\nB (4kb)\n\n\n1.43\n\n\n1.39\n\n\n1.42\n\n\n\n\nC (1kb)\n\n\n1.43\n\n\n1.78\n\n\n1.42\n\n\n\n\nD (10kb)\n\n\n0\n\n\n0\n\n\n0.009\n\n\n\n\nTotal\n\n\n4.29\n\n\n4.5\n\n\n4.25\n\n\n\n\n\n\n\nTPM\n\n\n\n\n\nGene Name\n\n\nRep1 TPM\n\n\nRep2 TPM\n\n\nRep3 TPM\n\n\n\n\n\n\nA (2kb)\n\n\n3.33\n\n\n2.96\n\n\n3.326\n\n\n\n\nB (4kb)\n\n\n3.33\n\n\n3.09\n\n\n3.326\n\n\n\n\nC (1kb)\n\n\n3.33\n\n\n3.95\n\n\n3.326\n\n\n\n\nD (10kb)\n\n\n0\n\n\n0\n\n\n0.02\n\n\n\n\nTotal\n\n\n10\n\n\n10\n\n\n10\n\n\n\n\n\n위 결과들은 같은 데이터에서 나온 RPKM과 TPM 값입니다. 둘 다 gene length와 sequencing depth의 편향(bias)이 일치합니다. 하지만 각 column에 대한 정규화된 총 reads는 매우 다릅니다.\n\nRPKM은 각 sample마다 다른 값을 얻었습니다.\nTPM은 각 column마다 같은 값을 얻었습니다.\n\n왜 이 차이가 중요한지 봐봅시다. \n\n\nComparison among TPMs\n\n\n\nComparison among RPKMs…?\n\n감이 오시나요?\nTPM은 모든 replicate에 대하여 총 count 수가 보정되었기 때문에 각 gene에 어떤 비율로 reads가 있는지 알 수 있습니다. 예를 들어 Rep1의 gene A는 33%라고 알 수 있습니다. 그리고 이를 통해 Rep2의 gene A와 비교하였을 때 Rep1의 gene A가 Rep2의 gene A보다 약간 크다고 알 수 있습니다. 이는 Rep1의 gene A에 맵핑된 양이 Rep3의 gene A에 맵핑된 양보다 미세하게 더 많다는 걸 알 수 있습니다.\n하지만 RPKM은 각각의 replicate가 다른 total reads를 가지기 때문에 각각의 replicate의 gene을 비교하기 어렵습니다. 이 말은 각각의 gene의 reads 수를 비교하기 어렵다는 말이 됩니다.\n\n\n따라서\nsample들 안에서 맵핑되는 reads의 비율을 보다 명확하게 말해주는 TPM을 사용하기를 추천드립니다.\n\n\n\nReference\n\nhttps://www.youtube.com/watch?v=TTUrtCY2k-w\nhttps://www.rna-seqblog.com/rpkm-fpkm-and-tpm-clearly-explained/\nhttp://www.incodom.kr/Expression_profiling\n\n\n\n\n\n\n\n라이센스https://creativecommons.org/licenses/by/4.0/deed.ko"
  },
  {
    "objectID": "posts/2023-03-15-fastq-format/index.html",
    "href": "posts/2023-03-15-fastq-format/index.html",
    "title": "FASTQ 포맷이란?",
    "section": "",
    "text": "FASTQ란 무엇인가요?\nFASTQ는 생물학적 서열 데이터, 특히 뉴클레오티드 서열 (DNA 또는 RNA) 및 해당 품질 점수를 저장하는 데 사용되는 텍스트 기반 형식입니다. 이는 Illumina 및 Ion Torrent 플랫폼과 같은 고처리량 시퀀싱(HTS) 기술에 의해 생성된 시퀀싱 데이터를 저장, 공유 및 분석하기 위해 생물 정보학 및 유전체학 분야에서 널리 사용됩니다.\n\n\nFASTQ format이란 무엇을 의미하는 걸까요?\nFASTQ 형식은 FASTQ 파일 내의 데이터 구조와 조직을 나타냅니다. FASTQ 파일의 각 항목은 단일 서열 독립본을 나타내며 네 줄로 구성됩니다. 이 형식은 각 염기와 관련된 품질 점수와 함께 서열 정보를 저장하기 위해 설계되었습니다.\n\n\nFASTA 포맷과의 차이점은?\nFASTA와 FASTQ 형식은 핵산 및 아미노산 서열을 나타내는 데 있어서 생물 정보학 분야에서 널리 사용됩니다. 그러나 두 형식 간에는 구조, 응용 분야 및 포함 정보 등의 중요한 차이점이 있습니다. (주요 차이점은 품질 정보의 유무와 용도입니다.)\nFASTA 포맷은 단순한 구조를 가지고 있어 연구자들이 유전자, 단백질 및 RNA 서열 데이터를 효율적으로 저장하고 공유할 수 있습니다. 특히, 각 서열은 ‘&gt;’ 기호로 시작하는 헤더와 이어지는 A, T, C, G(또는 단백질 서열의 경우 20가지 아미노산 코드)로 이루어진 서열로 구성됩니다. 따라서 FASTA 포맷은 서열 정렬, 유전체 데이터베이스 구축 및 활용 등 다양한 분야에서 사용됩니다.\n반면, FASTQ 포맷은 FASTA 포맷의 모든 정보에 더해, 서열 품질 정보를 제공합니다. 이 포맷은 네 줄로 구성되며, 첫 번째 줄은 ‘@’ 기호로 시작하는 헤더, 두 번째 줄은 서열 정보, 세 번째 줄은 ‘+’ 기호와 선택적인 설명 정보, 그리고 마지막 줄은 품질 점수를 ASCII 문자로 표현한 품질 정보를 담고 있습니다. 품질 점수는 서열의 각 염기에 대한 정확도를 나타내며, 이는 대부분의 경우 현대 DNA 서열 분석에서 매우 중요한 요소입니다.\n요약하자면, FASTA 포맷은 간단한 구조를 가지고 있어 다양한 생명과학 연구에 사용되지만, 품질 정보를 포함하지 않습니다. 반면 FASTQ 포맷은 품질 정보까지 포함하여 DNA 서열 분석에서 더욱 세밀한 연구를 가능케 합니다. 이에 따라 서열 데이터의 용도와 필요한 정보에 따라 연구자들은 적절한 포맷을 선택하여 사용합니다.\n 출처 11  https://learn.gencore.bio.nyu.edu/ngs-file-formats/fastq-format/\n\n\nFASTQ에서 각 줄이 무엇을 의미하나요?\nFASTQ 파일에서 네 줄 각각은 특정한 의미를 지니며 다음과 같습니다:\n\n1번째 줄: ’@’로 시작하며 서열 독립본에 대한 고유 식별자를 포함합니다. 이 식별자는 종종 시퀀싱 실행, 기기 또는 샘플에 대한 정보를 포함할 수도 있습니다.\n2번째 줄: 생물학적 데이터를 나타내는 순수한 뉴클레오티드 서열을 문자열로 나타냅니다(DNA의 경우 A, C, G, T; RNA의 경우 A, C, G, U). 이 줄은 시퀀싱 과정에서 얻은 실제 생물학적 데이터를 나타냅니다.\n3번째 줄: ’+’로 시작하여 선택적으로 설명 또는 1번째 줄과 동일한 식별자가 이어집니다. 이 줄은 서열과 품질 점수 사이의 구분자 역할을 합니다.\n4번째 줄: ASCII 문자로 표시된 각 염기의 품질 점수를 포함합니다. 이 점수는 시퀀싱 기기에서 생성되며 각 염기 콜의 확신도 또는 정확도를 나타냅니다. 품질 점수는 일반적으로 Phred 품질 점수 시스템을 사용하여 나타내며 높은 점수는 콜의 높은 신뢰도를 나타냅니다.\n\n이 네 줄은 FASTQ 파일의 단일 항목을 구성하며, 시퀀싱 데이터셋의 크기에 따라 파일에 수백만 개의 항목이 포함될 수 있습니다.\n 출처22  https://www.researchgate.net/publication/331702618/figure/fig2/AS:745823247810566@1554829527399/An-example-of-the-FASTA-format-used-in-iLearn.ppm\n\n\nFASTQ를 사용하는 툴들\nFASTQ 파일은 시퀀스 얼라인먼트, 게놈 어셈블리, 품질 통제 등 다양한 생물정보학 애플리케이션에서 널리 사용됩니다. 다음은 각 범주에서 FASTQ 파일을 사용하는 인기있는 소프트웨어 도구 몇 가지입니다.\nAligners(mappers):\n\nBWA(Burrows-Wheeler Aligner) - 대규모 참조 유전체에 대한 저다양한 시퀀스 매핑을 위한 널리 사용하는 도구입니다.\nBowtie2 - 시퀀싱 리드를 긴 참조 시퀀스에 정렬하기 위한 빠르고 메모리 효율적인 도구입니다.\nHISAT2 - 인간 유전체와 같은 대규모 참조 유전체에 대한 다음 세대 시퀀싱 리드(DNA 및 RNA 모두) 매핑을 위한 빠르고 민감한 정렬 도구입니다.\nSTAR(Spliced Transcripts Alignment to a Reference) - 비정형 스플라이스 및 키메릭(융합) 전사체를 발견 할 수 있는 RNA-seq 어셈블러입니다.\n\nAssemblers:\n\nSPAdes(St. Petersburg genome assembler) - 소규모 게놈, 단일 세포 및 메타 게놈 데이터를 위해 설계된 데 노 게놈 어셈블러입니다.\nVelvet - Illumina와 같은 단독 리드 시퀀싱 기술에 대한 데 노 게놈 어셈블러입니다.\nABySS(Assembly By Short Sequences) - 대규모 게놈에 대한 데 노, 병렬, 페어 엔드 시퀀스 어셈블러입니다.\nCanu - PacBio 및 Oxford Nanopore에서 생성 된 데이터와 같은 고노이즈 단일 분자 시퀀싱을 위해 설계된 Celera Assembler의 포크입니다.\n\nQuality Control (QC) Tools:\n\nFastQC - FASTQ 파일에서 원시 시퀀스 데이터의 품질을 평가하는 모듈러 세트를 제공하는 인기있는 도구입니다.\nPRINSEQ (PRocessing INtegrated SEQuence data) - FASTQ 파일과 같은 고처리량 시퀀싱 데이터를 전처리하고 필터링하는 도구입니다.\nMultiQC - 여러 샘플의 품질 통제 데이터를 단일 보고서로 집계하는 도구입니다.\nTrimmomatic - Illumina NGS 데이터에 대한 유연한 리드 트리밍 도구로 어댑터 시퀀스, 저품질 베이스 및 기타 잠재적 문제를 제거 할 수 있습니다.\n\n이것들은 FASTQ 파일을 활용하는 수많은 생물 정보학 도구 중 일부 예시일 뿐입니다. 많은 다른 도구들이 있으며, 각각은 특정 유형의 분석, 시퀀싱 기술 또는 생물체 게놈에 맞게 맞추어져 있습니다.\n\n\n참고하면 좋은 자료들:\nFASTQ 형식에 대한 정보와 FASTQ 파일 작업 도구를 제공하는 많은 온라인 자료가 있습니다. 다음은 시작하기에 유용한 자료입니다:\n\nThe original FASTQ format paper: Cock, P.J.A., Fields, C.J., Goto, N., Heuer, M.L., and Rice, P.M. (2010). The Sanger FASTQ file format for sequences with quality scores, and the Solexa/Illumina FASTQ variants. Nucleic Acids Research, 38(6), 1767-1771. doi:10.1093/nar/gkp1137 Available at: https://academic.oup.com/nar/article/38/6/1767/3112533\nThe Wikipedia page on FASTQ format provides a good overview and details on the format, as well as some relevant references: https://en.wikipedia.org/wiki/FASTQ_format\nNCBI의 시퀀스 독립 아카이브(SRA)는 FASTQ 형식으로 공개적으로 사용 가능한 많은 시퀀싱 데이터 컬렉션과 이러한 데이터에 액세스하고 다운로드하는 방법에 대한 문서 및 튜토리얼을 제공합니다: https://www.ncbi.nlm.nih.gov/sra\nFastQC는 FASTQ 파일의 품질을 검사하기 위해 널리 사용되는 도구입니다. 문서와 사용자 가이드에서는 FASTQ 파일과 관련된 품질 메트릭을 이해하고 해석하는 데 유용한 정보를 제공합니다: https://www.bioinformatics.babraham.ac.uk/projects/fastqc/\nGalaxy 플랫폼은 생물 정보학 분석을 위한 오픈소스 웹 기반 플랫폼으로, 접근성, 재현성 및 투명성을 갖춘 여러 가지 바이오 인포매틱스 도구 및 FASTQ 파일 작업을 위한 여러 가지 튜토리얼 및 교육 자료를 포함하고 있습니다. https://training.galaxyproject.org/\n온라인 포럼인 Biostars (https://www.biostars.org/)와 SEQanswers (http://seqanswers.com/)는 FASTQ 파일과 관련된 도구를 비롯한 바이오인포매틱스에 대한 다양한 주제를 논의하는 활발한 커뮤니티를 가지고 있습니다. 기존 토론을 검색하거나 질문을 할 수 있습니다.\n바이오인포매틱스에 관련된 온라인 강좌와 튜토리얼은 종종 FASTQ 파일과 이를 다루는 주제를 다룹니다. Coursera, edX와 등 인기 있는 플랫폼에서 해당 강좌를 제공합니다.\n\n이러한 자료들은 FASTQ 형식의 이해, FASTQ 파일 작업, 시퀀싱 데이터 처리 및 분석 도구 및 기술에 대한 핵심적인 기반을 제공합니다.\n\n\n\n\n\n라이센스https://creativecommons.org/licenses/by/4.0/deed.ko"
  },
  {
    "objectID": "posts/2021-02-20-how-to-save-apple-time-machine-mackups-to-cloud-services/index.html",
    "href": "posts/2021-02-20-how-to-save-apple-time-machine-mackups-to-cloud-services/index.html",
    "title": "맥 타임머신을 클라우드 서비스에 하기(원드라이브, 구글드라이브, 드랍박스 등)",
    "section": "",
    "text": "이 글은 Lhyam Sumal의 HOW TO SAVE APPLE TIME MACHINE BACKUPS TO CLOUD SERVICES LIKE ONEDRIVE 를 번역한 글입니다. 모든 저작권과 권리는 Sumal에게 있습니다.\nThis article is a translated version of Lhyam Sumal’s article: HOW TO SAVE APPLE TIME MACHINE BACKUPS TO CLOUD SERVICES LIKE ONEDRIVE. All rights goes back to him.\n*제가 이해한 대로 번역하였기 때문에 완벽하지 않을 수 있습니다.\n타임머신은 굉장한 기능이면서, 제 생각에는 macOS의 최고 기능입니다. 네, 윈도우에도 파일 히스토리가 있지만 타임머신만큼 포괄적인 것은 없습니다. 말 그대로 맥을 복원하고 프로그램을 다시 설치하거나 환경설정을 지정하거나 driver를 사용하지 않고도 이전에 중단한 위치를 정확하게 선택할 수 있습니다!\n그러나 백업하려면 외장하드가 연결되어야 합니다. 물론 2018년(원문이 쓰인 날)에는 클라우드 서비스에 백업할 수 있습니다. 저는 마이크로소프트 오피스 365를 구독해서 1TB의 공간을 가지고 있습니다. 문서, 사진, 음악, 비디오 및 데스크탑 폴더가 이미 원드라이브에 백업되는 반면에 내 프로그램들과 설정들은 어떤가요?\n놀랍게도 애플은 클라우드 서비스를 사용한 백업 옵션을 타임머신에서 제공하지 않습니다. 하지만 우리는 답을 찾을 것이다. 늘 그랬듯이..(의역)\n하지만 그렇게 열심히 찾아보지 않아도 되었습니다. 이전에 타임머신 백업을 네트워크 드라이브에 저장하는 방법을 약간의 수정을 통해서 할 수 있는 방법을 기사로 썼습니다. 다음은 타임머신을 원드라이브, 구글드라이브, 아이클라우드 또는 원하는 클라우드 서비스에 저장할 수 있는 방법입니다."
  },
  {
    "objectID": "posts/2021-02-20-how-to-save-apple-time-machine-mackups-to-cloud-services/index.html#어떻게-작동하는가",
    "href": "posts/2021-02-20-how-to-save-apple-time-machine-mackups-to-cloud-services/index.html#어떻게-작동하는가",
    "title": "맥 타임머신을 클라우드 서비스에 하기(원드라이브, 구글드라이브, 드랍박스 등)",
    "section": "어떻게 작동하는가?",
    "text": "어떻게 작동하는가?\n이 글의 목적상 원드라이브를 사용하고 있지만 다른 클라우드 서비스도 동일한 방식으로 작동합니다. 맥에서 이미 클라우드 동기화 서비스를 사용하고 있다고 가정하면 다음 단계를 따르는 것이 매우 간단하며 몇 분 정도 걸립니다.\n가상 드라이브를 생성하여 클라우드 서비스에 저장한 다음 맥에 마운트 해야 합니다. 타임머신 설정을 약간 조정하면 맥에서 가상 드라이브를 인식하고 자동으로 저장을 시작합니다.\nmacOS가 변경 사항을 가상 드라이브에 저장할 때마다 원드라이브 앱은 해당 변경사항을 클라우드에 다시 동기화합니다."
  },
  {
    "objectID": "posts/2021-02-20-how-to-save-apple-time-machine-mackups-to-cloud-services/index.html#가상-드라이브-생성",
    "href": "posts/2021-02-20-how-to-save-apple-time-machine-mackups-to-cloud-services/index.html#가상-드라이브-생성",
    "title": "맥 타임머신을 클라우드 서비스에 하기(원드라이브, 구글드라이브, 드랍박스 등)",
    "section": "가상 드라이브 생성",
    "text": "가상 드라이브 생성\n가상 드라이브의 장점은 전체 1TB를 가상 드라이브에 할당된 공간으로 지정하더라도 실제 차지하는 공간은 그 안에 포함된 파일의 크기만큼만 됩니다.\n클라우드 드라이브 폴더 내에 디스크 이미지를 저장해야 합니다. 맥에서 원드라이브 폴더를 찾고 디스크 이미지를 여기에 저장했습니다.\n\n디스크 유틸리티를 엽니다. 간단하게 Spotlight나 Alfred를 이용해 검색할 수 있습니다.- 파일 메뉴에서 새로운 이미지(New Image) &gt; 빈 이미지(Black Image)를 선택합니다. (단축키 cmd+n)\n클라우드 폴더를 찾아서 가상 드라이브 이름을 설정합니다. (MacBookTM)- 가상드라이브의 최대 용량을 입력합니다. 저의 경우 200 GB를 입력했습니다.- 포맷을 Mac OS 확장 (저널링)로 선택합니다.\n암호화는 사용해도 되고 안 해도 되는데 사용한다면 128-bit 를 선택합니다. 그러면 암호를 입력하는 창이 뜨는데 복구할 때 사용하기 때문에 잊어버리면 안 됩니다.\n파티션을 단일 파티션으로 설정합니다.\n마지막으로 이미지 포맷을 분할 번들 디스크 이미지(sparse bundle disk image)로 선택합니다.\n디스크 이미지 사이즈를 체크합니다. - 저의 경우 이미지 포맷을 변경하니까 사이즈가 기본으로 변경되어 다시 수정하였습니다.\n\n완료하였다면 디스크 유틸리티를 종료 할 수 있습니다."
  },
  {
    "objectID": "posts/2021-02-20-how-to-save-apple-time-machine-mackups-to-cloud-services/index.html#가상-드라이브-마운트",
    "href": "posts/2021-02-20-how-to-save-apple-time-machine-mackups-to-cloud-services/index.html#가상-드라이브-마운트",
    "title": "맥 타임머신을 클라우드 서비스에 하기(원드라이브, 구글드라이브, 드랍박스 등)",
    "section": "가상 드라이브 마운트",
    "text": "가상 드라이브 마운트\n저의 경우 자동으로 가상 드라이브가 마운트 되고 MacBookTM이 나타났습니다.\n자동으로 마운트 되지 않을 경우 파인더를 열고 디스크 이미지를 저장한 위치로 이동하여 두 번 클릭하면 됩니다."
  },
  {
    "objectID": "posts/2021-02-20-how-to-save-apple-time-machine-mackups-to-cloud-services/index.html#가상-드라이브를-인식하도록-타임머신-구성",
    "href": "posts/2021-02-20-how-to-save-apple-time-machine-mackups-to-cloud-services/index.html#가상-드라이브를-인식하도록-타임머신-구성",
    "title": "맥 타임머신을 클라우드 서비스에 하기(원드라이브, 구글드라이브, 드랍박스 등)",
    "section": "가상 드라이브를 인식하도록 타임머신 구성",
    "text": "가상 드라이브를 인식하도록 타임머신 구성\n이 파트는 조금 까다로워 보이지만 실제로는 간단합니다.\n\n\n\n저와 창이 다를 수 있습니다.\n\n\n\n터미널을 엽니다. (저와 다른 창이 떠도 괜찮습니다.)\n아래의 명령어를 입력합니다. 여기서 {mounted-disk-image}는 마운트 된 디스크의 이름입니다.\nsudo tmutil setdestination /Volumes/{mounted-disk-image}\n\n#저는 MacBookTimeMachine으로 했으니까 위의 이미지 처럼 입력하였습니다.\nEnter를 누르세요.\n비밀번호를 입력하라고 나오면 입력하고 Enter를 누르세요.\n입력이 완료되면 exit를 눌러 터미널을 종료합니다."
  },
  {
    "objectID": "posts/2021-02-20-how-to-save-apple-time-machine-mackups-to-cloud-services/index.html#타임머신-설정",
    "href": "posts/2021-02-20-how-to-save-apple-time-machine-mackups-to-cloud-services/index.html#타임머신-설정",
    "title": "맥 타임머신을 클라우드 서비스에 하기(원드라이브, 구글드라이브, 드랍박스 등)",
    "section": "타임머신 설정",
    "text": "타임머신 설정\n거의 다 끝났습니다. 👏\n\n시스템 환경설정에서 타임머신을 열면 새로 만든 드라이브가 자동으로 나타납니다."
  },
  {
    "objectID": "posts/2021-02-20-how-to-save-apple-time-machine-mackups-to-cloud-services/index.html#타임머신에서-onedrive-폴더-제외",
    "href": "posts/2021-02-20-how-to-save-apple-time-machine-mackups-to-cloud-services/index.html#타임머신에서-onedrive-폴더-제외",
    "title": "맥 타임머신을 클라우드 서비스에 하기(원드라이브, 구글드라이브, 드랍박스 등)",
    "section": "타임머신에서 OneDrive 폴더 제외",
    "text": "타임머신에서 OneDrive 폴더 제외\n이 부분은 권장하는 파트입니다. 그렇지 않으면 클라우드 동기화 폴더 포함하여 타임머신이 백업한 다음에 클라우드 동기화를 진행합니다.\n폴더를 제외하려면\n\n타임머신 환경설정에서 옵션을 클릭합니다.\n+ 아이콘을 클릭하고 클라우드 폴더를 선택합니다. (예: Onedrive 또는 googledrive)\n저장을 클릭합니다."
  },
  {
    "objectID": "posts/2021-02-20-how-to-save-apple-time-machine-mackups-to-cloud-services/index.html#그리고-당신은..",
    "href": "posts/2021-02-20-how-to-save-apple-time-machine-mackups-to-cloud-services/index.html#그리고-당신은..",
    "title": "맥 타임머신을 클라우드 서비스에 하기(원드라이브, 구글드라이브, 드랍박스 등)",
    "section": "그리고 당신은..",
    "text": "그리고 당신은..\n타임머신이 가상드라이브 백업을 시작하고 원드라이브에 해당 변경 사항을 동기화할 것입니다. 더는 외장하드를 검색하거나 네트워크 서버 연결을 기다릴 필요가 없습니다.\n백업을 다운받기 위해서 조금 고통스럽겠지만 저를 믿으세요!"
  },
  {
    "objectID": "posts/2021-02-20-how-to-save-apple-time-machine-mackups-to-cloud-services/index.html#코멘트",
    "href": "posts/2021-02-20-how-to-save-apple-time-machine-mackups-to-cloud-services/index.html#코멘트",
    "title": "맥 타임머신을 클라우드 서비스에 하기(원드라이브, 구글드라이브, 드랍박스 등)",
    "section": "📝코멘트",
    "text": "📝코멘트\n백업을 진행하다 보면 매우 느린 속도에 좌절하게 되지만 이 속도를 개선해 줄 방법이 있습니다. 아래의 링크를 참고해주세요.\n\n맥에서 타임머신 백업 시간을 크게 줄여주는 마법 같은 명령어"
  },
  {
    "objectID": "posts/2023-03-29-Why-single-cell-RNA-seq/index.html",
    "href": "posts/2023-03-29-Why-single-cell-RNA-seq/index.html",
    "title": "[scRNA-seq 시리즈-1] single-cell RNA-seq 소개",
    "section": "",
    "text": "이 글은 Harvard Chan Bioinformatics Core의 scRNA-seq 입문을 번역한 글입니다. 의역이 포함되어있습니다."
  },
  {
    "objectID": "posts/2023-03-29-Why-single-cell-RNA-seq/index.html#conclusions",
    "href": "posts/2023-03-29-Why-single-cell-RNA-seq/index.html#conclusions",
    "title": "[scRNA-seq 시리즈-1] single-cell RNA-seq 소개",
    "section": "Conclusions",
    "text": "Conclusions\nscRNA-seq는 단일 세포 해상도로 유전자 발현을 분석하기 위한 강력하고 통찰력 있는 방법이지만, 데이터 분석을 복잡하게 하거나 제한하는 많은 도전과 변동 원인이 있습니다. scRNA-seq 데이터의 분석 과정에서, 데이터에서 관심 없는 변동 원인에 따른 변동을 설명하거나 제거하려고 노력할 것입니다.\n전반적으로, 다음을 권장합니다:\n\n실험적인 질문에 대한 답변을 얻기 위해, 단일 세포 RNA-seq을 꼭 필요한 경우에만 수행하세요. 더 단순하고 비용 효율적인 대체 방법이 있는지 고려해보세요. 샘플을 병합하여 대량 분석할 수 있는 방법이 있을 수 있습니다.\n해결하고자 하는 실험 질문의 세부 사항을 이해하세요. 특정 실험에 따라 권장되는 라이브러리 준비 방법과 분석 워크플로우가 달라질 수 있습니다.\n가능하다면 기술적인 변이 요소를 회피하세요:\n\n실험 계획을 전문가와 상의하세요.\n샘플에서 RNA을 동시에 분리하세요.\n동일한 시간에 라이브러리를 준비하거나 일괄 처리 효과를 피하기 위해 교대로 샘플 그룹을 나누세요.\n성별, 연령 또는 일괄 처리 효과 등으로 샘플 그룹을 혼동하지 마세요.\n\n\n\n\n\n\n\n\n단일핵 RNA-seq(snRNA-seq)와 단일세포 RNA-seq(scRNA-seq)의 차이는 무엇인가요?\n\n\n\n\n이 글에서는 snRNA-seq를 다루지 않습니다! 아래에는 snRNA-seq에 대한 간단한 개요가 있습니다.\n\nsnRNA-seq은 완전한 세포 대신 핵에서의 발현 프로파일을 분석합니다. 예상할 수 있듯이 핵에서 검출되는 전사물이 적습니다(~7,000개의 유전자), 반면 완전한 세포에서는 (~11,000개의 유전자)가 검출됩니다. 일부 상황(연구 자료와 목표에 따라 다름)에서는 scRNA-seq보다 snRNA-seq가 선호되는 방법일 수 있습니다.\nsnRNA-seq의 몇 가지 장점은 다음과 같습니다:\n- 분리하기 어려운 샘플(예: 지방세포)과 동결된 조직에서 잘 작동함\n- 분리 과정에서 발생하는 전사 산물에 대한 오류(아티팩트)를 줄여줌\n- 덜 편향된 세포 커버리지를 제공함"
  },
  {
    "objectID": "posts/2023-03-29-Why-single-cell-RNA-seq/index.html#reference",
    "href": "posts/2023-03-29-Why-single-cell-RNA-seq/index.html#reference",
    "title": "[scRNA-seq 시리즈-1] single-cell RNA-seq 소개",
    "section": "Reference",
    "text": "Reference\n\nhttps://hbctraining.github.io/scRNA-seq_online/lessons/01_intro_to_scRNA-seq.html\nTrapnell, C. Defining cell types and states with single-cell genomics, Genome Research 2015 (doi: https://dx.doi.org/10.1101/gr.190595.115"
  },
  {
    "objectID": "posts/2022-02-25-pytorch-tensor/2022-02-25-pytorch-tensor.html",
    "href": "posts/2022-02-25-pytorch-tensor/2022-02-25-pytorch-tensor.html",
    "title": "PyTorch - 01_텐서(Tensor)",
    "section": "",
    "text": "Important: 본 내용은 파이토치 한국 사용자 모임의 튜토리얼의 내용이다."
  },
  {
    "objectID": "posts/2022-02-25-pytorch-tensor/2022-02-25-pytorch-tensor.html#numpy-배열을-텐서로-변환하기",
    "href": "posts/2022-02-25-pytorch-tensor/2022-02-25-pytorch-tensor.html#numpy-배열을-텐서로-변환하기",
    "title": "PyTorch - 01_텐서(Tensor)",
    "section": "NumPy 배열을 텐서로 변환하기",
    "text": "NumPy 배열을 텐서로 변환하기\n\nn = np.ones(5)\nt = torch.from_numpy(n) \n\nNumPy 배열의 변경 사항이 텐서에 반영됩니다.\n\nnp.add(n, 1, out=n)\nprint(f\"t: {t}\")\nprint(f\"n: {n}\")\n\nt: tensor([2., 2., 2., 2., 2.], dtype=torch.float64)\nn: [2. 2. 2. 2. 2.]"
  },
  {
    "objectID": "eng.study/2022-10-16-exciting/index.html",
    "href": "eng.study/2022-10-16-exciting/index.html",
    "title": "신난다, 흥분된다!",
    "section": "",
    "text": "라는 말을 영어로 하면, 보통 I'm so excited 라고 말한다.\n물론, 맞는 표현이지만 이 표현만 사용한다기 보다는 다른 표현도 알아두면 좋다.\n다른 표현으로는,\n\n\n나 정말 신나!, 기대돼! 라는 표현이다.\n먼저 직역해보자면 “나 펌프됐다.” 정도로 해석이 가능한데, 말 그대로다.\n내가 펌프됐다. -&gt; 내가 흥분했다. 의미로 연결할 수 있다.\n간혹, 드라마에서 “I’m pumped out”라는 표현을 쓰는데 이 경우는 “나 정말 지쳤어” 정도로 해석해야 한다. 상황에 따라서 맞게 해석해야 오해가 생기지 않는다.\n(지쳐있는 얼굴 표정을 흥분한 것으로 오해하지 않으려면..)\n(I’m pumped to run this marathon. 처럼 out을 생략해서 사용하기도 하니, 상황을 잘 보아야 한다.)\n\n\n\nA: Are you going to the concert tonight?\nB: Yes, I’m already pumped.\nI’m pumped up to go skydiving.\nI’m so pumped for tonigh’s concert\nI’m so pumped for today workout"
  },
  {
    "objectID": "eng.study/2022-10-16-exciting/index.html#im-pumped",
    "href": "eng.study/2022-10-16-exciting/index.html#im-pumped",
    "title": "신난다, 흥분된다!",
    "section": "",
    "text": "나 정말 신나!, 기대돼! 라는 표현이다.\n먼저 직역해보자면 “나 펌프됐다.” 정도로 해석이 가능한데, 말 그대로다.\n내가 펌프됐다. -&gt; 내가 흥분했다. 의미로 연결할 수 있다.\n간혹, 드라마에서 “I’m pumped out”라는 표현을 쓰는데 이 경우는 “나 정말 지쳤어” 정도로 해석해야 한다. 상황에 따라서 맞게 해석해야 오해가 생기지 않는다.\n(지쳐있는 얼굴 표정을 흥분한 것으로 오해하지 않으려면..)\n(I’m pumped to run this marathon. 처럼 out을 생략해서 사용하기도 하니, 상황을 잘 보아야 한다.)\n\n\n\nA: Are you going to the concert tonight?\nB: Yes, I’m already pumped.\nI’m pumped up to go skydiving.\nI’m so pumped for tonigh’s concert\nI’m so pumped for today workout"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "블로그",
    "section": "",
    "text": "어떤 reference genome을 사용해야 할까?\n\n\n\n\n\n\n\nBioinformatics\n\n\n\n\n\n\n\n\n\n\n\n2023/03/29\n\n\n4 min\n\n\n\n\n\n\n  \n\n\n\n\nRPKM, FPKM, TPM이 무엇인가?\n\n\n\n\n\n\n\nBioinformatics\n\n\n\n\n각각 어떤 의미를 가지고 있는지 알아보자\n\n\n\n\n\n\n2023/03/29\n\n\n4 min\n\n\n\n\n\n\n  \n\n\n\n\n[scRNA-seq 시리즈-1] single-cell RNA-seq 소개\n\n\n\n\n\n\n\nBioinformatics\n\n\n\n\n왜 single-cell RNA-seq인가?\n\n\n\n\n\n\n2023/03/29\n\n\n6 min\n\n\n\n\n\n\n  \n\n\n\n\nFASTQ 포맷이란?\n\n\n\n\n\n\n\nBioinformatics\n\n\n\n\nFASTQ란 무엇인가? FASTA와 다른점은?\n\n\n\n\n\n\n2023/03/15\n\n\n5 min\n\n\n\n\n\n\n  \n\n\n\n\n유전체 분석을 위한 파이썬 라이브러리 소개\n\n\n\n\n\n\n\nBioinformatics\n\n\n\n\n\n\n\n\n\n\n\n2023/02/28\n\n\n8 min\n\n\n\n\n\n\n  \n\n\n\n\np-value(유의 확률)란 무엇인가?\n\n\n\n\n\n\n\nstat\n\n\n\n\np-value를 이해하고 어떤 의미를 가지는지 알아보자\n\n\n\n\n\n\n2022/11/13\n\n\n2 min\n\n\n\n\n\n\n  \n\n\n\n\n데이터 과학자(Data Scientist)가 되기 위한 10단계\n\n\n\n\n\n\n\netc\n\n\n\n\n데이터 과학자가 되기 위해선..?\n\n\n\n\n\n\n2022/10/05\n\n\n2 min\n\n\n\n\n\n\n  \n\n\n\n\nPyTorch - 01_텐서(Tensor)\n\n\n\n\n\n\n\npytorch\n\n\n\n\nPyTorch의 기본 구조인 텐서에 대해서 알아본다.\n\n\n\n\n\n\n2022/02/25\n\n\n2 min\n\n\n\n\n\n\n  \n\n\n\n\nR DESeq2 패키지 python으로 포팅\n\n\n\n\n\n\n\nR\n\n\n\n\nrpy2를 활용하여 DESeq2 패키지 파이썬에서 사용하기\n\n\n\n\n\n\n2022/02/18\n\n\n1 min\n\n\n\n\n\n\n  \n\n\n\n\n여러개의 ROC-Curves를 하나의 plot 안에 그리는 방법\n\n\n\n\n\n\n\nML\n\n\n\n\n여러 모델의 AUC를 비교하기 위한 최고의 방법\n\n\n\n\n\n\n2022/01/19\n\n\n1 min\n\n\n\n\n\n\n  \n\n\n\n\n우분투에 NAS 마운트\n\n\n\n\n\n\n\nubuntu\n\n\n\n\nNAS에 백업된 다수의 대용량 파일에 쉽게 접근하기\n\n\n\n\n\n\n2021/05/08\n\n\n2 min\n\n\n\n\n\n\n  \n\n\n\n\n보통은 잘 모르는 파이썬 내장함수 3가지\n\n\n\n\n\n\n\npython\n\n\n\n\nmap, filter, reduce에 해서 알아보자\n\n\n\n\n\n\n2021/04/27\n\n\n2 min\n\n\n\n\n\n\n  \n\n\n\n\n🐳 Dockerfile 명령어 RUN, CMD, ENTRYPOINT 차이\n\n\n\n\n\n\n\ndocker\n\n\n\n\nRUN, CMD, ENTRYPOINT 차이에 대해 알아보자\n\n\n\n\n\n\n2021/04/15\n\n\n2 min\n\n\n\n\n\n\n  \n\n\n\n\n맥 타임머신을 클라우드 서비스에 하기(원드라이브, 구글드라이브, 드랍박스 등)\n\n\n\n\n\n\n\nmac\n\n\n\n\n\n\n\n\n\n\n\n2021/02/20\n\n\n3 min\n\n\n\n\n\n\n  \n\n\n\n\n구글 프로필 사진 다운로드하기\n\n\n\n\n\n\n\netc\n\n\n\n\n\n\n\n\n\n\n\n2021/02/19\n\n\n1 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "research.html",
    "href": "research.html",
    "title": "연구 아카이브",
    "section": "",
    "text": "Researcher (2019.09-현재)\n\n항암제 복합처방을 위한 인공지능 약물 추천시스템 (2020.11 ~ 2022.10 / EuroStars2 산업통상자원부)\n\n환자의 유전체 및 다양한 오믹스 데이터 분석 기술\n\n다중오믹스 폐암 바이오마커 패널 제작 및 인공지능 SW 개발 (2021.04 ~ 2021.10)\n\n유전체, 전사체, 후성유전체의 다중오믹스 기반 암 분석파이프라인 구축\n인공지능 폐암 진단 알고리즘 개발\n\n유방암 환자 빅데이터를 이용한 임상 약물 추천 서비스 개발 (2020.09~ 2022.09 / 중소벤처기업부)\n\n암환자 유전체 데이터(NGS) 분석 파이프라인 구축\n\n표현형과 유전형 기반의 디지털 행동 분석 및 개입 모델 서비스 (2020.09 ~ 2020.12)\n\n표현형과 유전형 기반의 질병 상관도 분석\n코호트 기반 개인별 건강 검진 데이터와 코호트 대상자의 유전체 데이터 구축\n\n암 타겟 단백질 10종 텍스트 데이터베이스 구축 (2020.07 ~ 2020.12)\n\n암질환에 특이적인 PROTAC 타겟 발굴을 위한 텍스트마이닝 수행, 단백질 사전 구축, 단백질 상호작용 추출, 신호전달 추출, pubmed, pubmed central, 미국특허 정보 추출\n\n빅데이터를 이용한 신약개발 SW 개발 (~2019.12 / 과학기술정통부)\n\n신약 탐색을 위한 유전체 NGS 분석 파이프라인 개발"
  },
  {
    "objectID": "research.html#alopax-algo",
    "href": "research.html#alopax-algo",
    "title": "연구 아카이브",
    "section": "",
    "text": "Researcher (2019.09-현재)\n\n항암제 복합처방을 위한 인공지능 약물 추천시스템 (2020.11 ~ 2022.10 / EuroStars2 산업통상자원부)\n\n환자의 유전체 및 다양한 오믹스 데이터 분석 기술\n\n다중오믹스 폐암 바이오마커 패널 제작 및 인공지능 SW 개발 (2021.04 ~ 2021.10)\n\n유전체, 전사체, 후성유전체의 다중오믹스 기반 암 분석파이프라인 구축\n인공지능 폐암 진단 알고리즘 개발\n\n유방암 환자 빅데이터를 이용한 임상 약물 추천 서비스 개발 (2020.09~ 2022.09 / 중소벤처기업부)\n\n암환자 유전체 데이터(NGS) 분석 파이프라인 구축\n\n표현형과 유전형 기반의 디지털 행동 분석 및 개입 모델 서비스 (2020.09 ~ 2020.12)\n\n표현형과 유전형 기반의 질병 상관도 분석\n코호트 기반 개인별 건강 검진 데이터와 코호트 대상자의 유전체 데이터 구축\n\n암 타겟 단백질 10종 텍스트 데이터베이스 구축 (2020.07 ~ 2020.12)\n\n암질환에 특이적인 PROTAC 타겟 발굴을 위한 텍스트마이닝 수행, 단백질 사전 구축, 단백질 상호작용 추출, 신호전달 추출, pubmed, pubmed central, 미국특허 정보 추출\n\n빅데이터를 이용한 신약개발 SW 개발 (~2019.12 / 과학기술정통부)\n\n신약 탐색을 위한 유전체 NGS 분석 파이프라인 개발"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "wjd5480@gmail.com"
  },
  {
    "objectID": "about.html#contact",
    "href": "about.html#contact",
    "title": "About",
    "section": "",
    "text": "wjd5480@gmail.com"
  },
  {
    "objectID": "about.html#interests",
    "href": "about.html#interests",
    "title": "About",
    "section": "⚡️ Interests",
    "text": "⚡️ Interests\nBioinformatics\nData Scientist\nDeep Learning"
  },
  {
    "objectID": "about.html#educations-and-research-experiences",
    "href": "about.html#educations-and-research-experiences",
    "title": "About",
    "section": "🏫 Educations and Research Experiences",
    "text": "🏫 Educations and Research Experiences\n\nEducations\nMaster of Science in Dental Science\nSeoul National University, Seoul, South Korea\nGraduation Date: Feb 2022\nRelevant Coursework: bioinformatics, Data Analysis, Big data handling"
  }
]